{{>layouts/header}}
<style>
    body {
        background-color: #f8f9fa;
    }

    /* ìƒë‹¨ ì„ íƒ ì •ë³´ ë°” */
    .top-status-bar {
        position: sticky;
        top: 0;
        z-index: 20;
        background-color: #ffffff;
        border-bottom: 1px solid #dee2e6;
        padding: 0.9rem 1.5rem;
        min-height: 64px;
    }

    .menu-card {
        cursor: pointer;
        transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease;
        border-width: 2px;
        border-color: transparent;
        height: 100%;
        display: flex;
        flex-direction: column;
        border-radius: 1rem;
        position: relative;
        overflow: hidden;
        background-color: #ffffff;
    }

    .menu-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 0.4rem 1rem rgba(0, 0, 0, 0.08);
    }

    .menu-card.selected {
        border-color: #0d6efd;
        box-shadow: 0 0.4rem 1rem rgba(13, 110, 253, 0.25);
    }

    /* === í° ì¹´ë“œì˜ ì ‘íŒ ëª¨ì„œë¦¬ (ì¢Œì¸¡ ìƒë‹¨) === */
    .menu-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 56px;
        height: 56px;
        clip-path: polygon(0 0, 100% 0, 0 100%);
        background-color: transparent;
        z-index: 0;
    }

    .menu-card[data-recipe-temp="HOT"]::before {
        background-color: #dc3545;
    }

    .menu-card[data-recipe-temp="ICE"]::before {
        background-color: #0d6efd;
    }

    .menu-card .card-body {
        position: relative;
        z-index: 1;
    }

    /* ìƒë‹¨ ë ˆì‹œí”¼ ë²ˆí˜¸(#10) */
    .recipe-id-label {
        font-size: 3.3rem;
        font-weight: 800;
        color: #6c757d;
        text-align: center;
        margin-bottom: 0.25rem;
        letter-spacing: 0.06em;
    }

    .menu-name {
        font-size: 2rem;
        font-weight: 800;
        text-align: center;
    }

    .menu-tag {
        font-size: 0.9rem;
        border-radius: 999px;
        padding: 0.1rem 0.5rem;
    }

    .card-count-badge {
        font-size: 0.85rem;
    }

    /* ===== ë ˆì‹œí”¼ ì¹´ë“œ ê·¸ë¦¬ë“œ (4ì—´) ===== */
    .menu-grid-wrapper {
        height: calc(100vh - 210px);
        max-height: calc(100vh - 210px);
        overflow-y: auto;
    }

    .menu-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        grid-auto-rows: 1fr;
        grid-auto-flow: row;
        gap: 1rem;
        height: 100%;
    }

    .menu-grid-item {
        display: flex;
    }

    .menu-grid-item .menu-card {
        width: 100%;
    }

    /* ===== HOT / ICE ë°°ì§€ ===== */
    .temp-badge {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.4rem 1rem;
        padding-left: 1.4rem;
        border-radius: 999px;
        background-color: #ffffff;
        border: 3px solid;
        font-size: 1.3rem;
        font-weight: 800;
        gap: 0.25rem;
        line-height: 1;
        overflow: hidden;
    }

    .temp-badge::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 24px;
        height: 24px;
        clip-path: polygon(0 0, 100% 0, 0 100%);
    }

    .temp-HOT {
        border-color: #dc3545;
        color: #dc3545;
    }

    .temp-ICE {
        border-color: #0d6efd;
        color: #0d6efd;
    }

    .temp-HOT::before {
        background-color: #dc3545;
    }

    .temp-ICE::before {
        background-color: #0d6efd;
    }

    .temp-HOT::after {
        content: "ğŸ”¥";
        margin-left: 0.3rem;
        font-size: 1.4rem;
    }

    .temp-ICE::after {
        content: "â„";
        margin-left: 0.3rem;
        font-size: 1.4rem;
    }

    /* OZ (ì»µ ì‚¬ì´ì¦ˆ) ë°°ì§€ */
    .cup-badge {
        font-size: 1.3rem;
        font-weight: 800;
        padding: 0.2rem 0.8rem;
        border-radius: 999px;
        background-color: #f8f9fa;
        border: 2px solid #adb5bd;
    }

    /* ===== ë ˆì‹œí”¼ íŒì—…(ëª¨ë‹¬) ===== */
    .recipe-modal {
        position: fixed;
        inset: 0;
        z-index: 1050;
        display: none;
        align-items: center;
        justify-content: center;
    }

    .recipe-modal.show {
        display: flex;
    }

    .recipe-modal-backdrop {
        position: absolute;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.45);
    }

    .recipe-modal-dialog {
        position: relative;
        z-index: 1060;
        background-color: #ffffff;
        border-radius: 0.75rem;
        max-width: 1280px;
        width: 95%;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 0.75rem 1.5rem rgba(0, 0, 0, 0.25);
        padding: 1.25rem 1.5rem 1.5rem;
        margin: 0 1rem;
    }

    .recipe-modal-header {
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        margin-bottom: 1rem;
    }

    .recipe-modal-header-right {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .recipe-modal-title {
        font-size: 2rem;
        font-weight: 700;
        margin: 0;
    }

    .recipe-modal-body {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: 0.5rem;
    }

    /* ===== ìŠ¤í… í–‰ + íƒ€ì´ë¨¸ ===== */
    .recipe-step {
        position: relative;
        background-color: #ffffff;
        border-radius: 0.5rem;
        padding: 1.3rem 1.5rem;
        margin-bottom: 1.8rem;
        box-shadow: 0 0.35rem 0.8rem rgba(0, 0, 0, 0.08);
        border-left: 6px solid #0d6efd;
        font-size: 2.2rem;
        line-height: 1.6;
        cursor: pointer;
        transition: background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .step-main {
        display: flex;
        align-items: center;
        flex: 1;
        min-width: 0;
    }

    .step-index {
        font-weight: 900;
        margin-right: 0.7rem;
        flex-shrink: 0;
    }

    .step-text {
        display: inline-block;
        vertical-align: middle;
        word-break: break-word;
    }

    .recipe-step.step-selected {
        background-color: #0d6efd;
        color: #ffffff;
        box-shadow: 0 0.35rem 0.9rem rgba(13, 110, 253, 0.45);
    }

    .recipe-step.step-selected .step-timer-value {
        color: #0f5132;
    }

    .btn-close {
        border: none;
        background: transparent;
        font-size: 1.7rem;
        line-height: 1;
    }

    /* ğŸ”Š TTS í† ê¸€ ë²„íŠ¼ */
    .tts-toggle-btn {
        border: none;
        background: transparent;
        font-size: 1.9rem;
        line-height: 1;
        cursor: pointer;
        padding: 0 0.1rem;
        transition: transform 0.08s ease, opacity 0.1s ease;
    }
    .tts-toggle-btn.off {
        opacity: 0.35;
    }
    .tts-toggle-btn.on {
        opacity: 1;
        transform: scale(1.05);
    }

    /* ğŸ™ ìƒë‹¨ ê³µìš© ìŒì„± ì¸ì‹ ë²„íŠ¼ */
    .top-mic-btn {
        border-radius: 999px;
        border: 2px solid rgba(15,23,42,0.4);
        background-color: #ffffff;
        width: 50px;
        height: 50px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        cursor: pointer;
        margin-left: 0.75rem;
        box-shadow: 0 3px 10px rgba(15,23,42,0.25);
        transition: background-color 0.12s ease, transform 0.08s ease,
        box-shadow 0.12s ease, border-color 0.12s ease;
    }

    .top-mic-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 5px 14px rgba(15,23,42,0.35);
    }

    /* ë§ˆì´í¬ ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes micBlink {
        0% {
            box-shadow: 0 3px 10px rgba(15,23,42,0.25);
            opacity: 1;
        }
        50% {
            box-shadow: 0 0 0 4px rgba(13,110,253,0);
            opacity: 0.45;
        }
        100% {
            box-shadow: 0 3px 10px rgba(15,23,42,0.25);
            opacity: 1;
        }
    }

    .top-mic-btn.listening {
        background-color: #0d6efd;
        color: #ffffff;
        border-color: #0a58ca;
        box-shadow: 0 0 0 4px rgba(13,110,253,0.45);
        transform: translateY(0);
        animation: micBlink 1s ease-in-out infinite;
    }

    /* ë ˆì‹œí”¼ ì—†ìŒ íŒì—… */
    .no-recipe-popup {
        position: fixed;
        z-index: 2000;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        border-radius: 0.75rem;
        padding: 0.75rem 1.5rem;
        box-shadow: 0 0.75rem 1.5rem rgba(0,0,0,0.25);
        border: 1px solid #dee2e6;
        font-size: 1rem;
        font-weight: 600;
        color: #343a40;
        display: none;
    }
    .no-recipe-popup.show {
        display: block;
    }

    .auto-play-switch .form-check-input {
        cursor: pointer;
    }

    /* ê° ìŠ¤í… ìš°ì¸¡ ë ì›í˜• íƒ€ì´ë¨¸ */
    .step-timer {
        width: 48px;
        height: 48px;
        position: relative;
        flex-shrink: 0;
        margin-left: 0.75rem;
    }

    .step-timer-svg {
        width: 48px;
        height: 48px;
        display: block;
        transform: rotate(-90deg); /* ìœ„(12ì‹œ)ì—ì„œ ì‹œì‘ */
    }

    .step-timer-bg-circle {
        stroke: #e9ecef;
        stroke-width: 6;     /* í…Œë‘ë¦¬ êµµê²Œ */
        fill: none;
    }

    .step-timer-progress-circle {
        stroke: #198754;
        stroke-width: 6;     /* í…Œë‘ë¦¬ êµµê²Œ */
        fill: none;
        stroke-linecap: round;
        transition: stroke-dashoffset 0.4s ease-in-out;  /* ì¡°ê¸ˆ ë” ë¶€ë“œëŸ½ê²Œ */
    }

    .step-timer-value {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: 700;
        color: #198754;
        font-size: 1rem;
        line-height: 1;
        text-align: center;
        pointer-events: none;
    }

</style>

<div class="container-fluid py-3">

    <!-- ìƒë‹¨ ì„ íƒ ìƒíƒœ ë°” -->
    <div class="top-status-bar d-flex flex-wrap align-items-center justify-content-between mb-3">
        <!-- ì¢Œì¸¡: ì•ˆë‚´ + ë§ˆì´í¬ -->
        <div class="d-flex flex-column flex-sm-row flex-wrap align-items-sm-center gap-2">
            <div class="fw-bold d-flex align-items-center">
                <span>ì£¼ìš” ë ˆì‹œí”¼ë¥¼ ì„ íƒí•˜ì„¸ìš”</span>
                <span class="text-muted ms-1">(í•œ ë²ˆì— í•˜ë‚˜ë§Œ ì„ íƒ)</span>

                <!-- ğŸ™ ìƒë‹¨ ê³µìš© ë§ˆì´í¬ ë²„íŠ¼ -->
                <button type="button"
                        id="btn-voice-recipe"
                        class="top-mic-btn"
                        title="ìŒì„±ì¸ì‹ êº¼ì§ Â· ëˆ„ë¥´ê³  'í—¬ë¦¬ì•¼ / ë ˆì‹œí”¼ ì´ë¦„ / ë²ˆí˜¸ / ë‹¤ìŒ / ê·¸ë§Œ / ìŒì„±ì¸ì‹ ê·¸ë§Œ'ì„ ë§í•´ë³´ì„¸ìš”.">
                    ğŸ™
                </button>
            </div>
        </div>

        <!-- ìš°ì¸¡: ì„ íƒ ì¹´ìš´íŠ¸ + ìë™ì¬ìƒ ìŠ¬ë¼ì´ë” -->
        <div class="d-flex align-items-center gap-3 mt-2 mt-sm-0">
            <span class="badge bg-primary card-count-badge">
                ì„ íƒí•œ ë ˆì‹œí”¼
                <span id="selected-count" class="fw-bold ms-1">0</span> / 1
            </span>

            <div class="form-check form-switch mb-0 auto-play-switch">
                <input class="form-check-input" type="checkbox" id="auto-play-toggle">
                <label class="form-check-label small" for="auto-play-toggle">
                    ìë™ì¬ìƒ
                </label>
            </div>
        </div>
    </div>

    <!-- ë ˆì‹œí”¼ ì¹´ë“œ ê·¸ë¦¬ë“œ (4ì—´) -->
    <div class="menu-grid-wrapper mb-4">
        <div class="menu-grid">
            {{#recipeRows}}
                <div class="menu-grid-item">
                    <div class="card menu-card"
                         data-recipe-id="{{id}}"
                         data-recipe-name="{{menuName}}"
                         data-recipe-temp="{{temperature}}">

                        <div class="card-body d-flex flex-column justify-content-center align-items-center">
                            <!-- ë ˆì‹œí”¼ ë²ˆí˜¸(#10) -->
                            <div class="recipe-id-label">
                                #{{id}}
                            </div>

                            <!-- ê°€ìš´ë° í¬ê²Œ ë©”ë‰´ ì´ë¦„ -->
                            <div class="menu-name mb-2">
                                {{menuName}}
                            </div>

                            <!-- ì•„ë˜ì— ì¹´í…Œê³ ë¦¬ / íƒœê·¸ë“¤ -->
                            <div class="d-flex flex-column align-items-center gap-2">
                                {{#category}}
                                    <span class="badge text-bg-light">
                                        {{category}}
                                    </span>
                                {{/category}}

                                <div class="d-flex justify-content-center align-items-center gap-2">
                                    {{#temperature}}
                                        <span class="temp-badge temp-{{temperature}}">
                                            {{temperature}}
                                        </span>
                                    {{/temperature}}

                                    {{#cupSize}}
                                        <span class="cup-badge">
                                            {{cupSize}}
                                        </span>
                                    {{/cupSize}}
                                </div>
                            </div>

                            <!-- ìˆ¨ê²¨ì§„ ë ˆì‹œí”¼ ìŠ¤í… (ëª¨ë‹¬ìš©) -->
                            <div class="d-none recipe-steps" id="recipe-steps-{{id}}">
                                {{#steps}}
                                    <div class="recipe-step-text">{{.}}</div>
                                {{/steps}}

                                {{#stepTimes}}
                                    <div class="recipe-step-time">{{.}}</div>
                                {{/stepTimes}}

                                {{^steps}}
                                    <div class="recipe-step-text text-muted">ë“±ë¡ëœ ìŠ¤í…ì´ ì—†ìŠµë‹ˆë‹¤.</div>
                                {{/steps}}
                            </div>
                        </div>
                    </div>
                </div>
            {{/recipeRows}}

            {{^recipeRows}}
                <div class="menu-grid-item">
                    <div class="alert alert-warning mb-0 w-100">
                        í‘œì‹œí•  ë ˆì‹œí”¼ê°€ ì—†ìŠµë‹ˆë‹¤. <code>visible == true</code> ì¸ ë ˆì‹œí”¼ë¥¼ ë“±ë¡í•´ ì£¼ì„¸ìš”.
                    </div>
                </div>
            {{/recipeRows}}
        </div>
    </div>
</div>

<!-- ë ˆì‹œí”¼ íŒì—…(ëª¨ë‹¬) -->
<div id="recipe-modal" class="recipe-modal">
    <div class="recipe-modal-backdrop" id="recipe-modal-backdrop"></div>
    <div class="recipe-modal-dialog">
        <div class="recipe-modal-header">
            <h5 class="recipe-modal-title" id="recipe-modal-title">ë ˆì‹œí”¼</h5>
            <div class="recipe-modal-header-right">
                <!-- ğŸ”Š TTS í† ê¸€ ë²„íŠ¼ (ê¸°ë³¸ OFF) -->
                <button type="button"
                        class="tts-toggle-btn off"
                        id="btn-tts-toggle"
                        title="ìë™ ìŒì„± ì•ˆë‚´ ì¼œê¸°">
                    ğŸ”ˆ
                </button>
                <button type="button" class="btn-close" id="btn-close-recipe" aria-label="Close">&times;</button>
            </div>
        </div>
        <div class="recipe-modal-body" id="recipe-modal-body">
            <p class="text-muted small mb-0">
                ì„ íƒí•œ ë ˆì‹œí”¼ì˜ ìŠ¤í…ì´ ì—¬ê¸° ê³„ë‹¨í˜•ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
            </p>
        </div>
    </div>
</div>

<!-- ë ˆì‹œí”¼ ì—†ìŒ íŒì—… -->
<div id="no-recipe-popup" class="no-recipe-popup">
    ë ˆì‹œí”¼ê°€ ì—†ìŠµë‹ˆë‹¤.
</div>

<script>
    (function () {

        const cards = document.querySelectorAll('.menu-card');
        const selectedCountSpan = document.getElementById('selected-count');

        const recipeModal = document.getElementById('recipe-modal');
        const recipeModalBackdrop = document.getElementById('recipe-modal-backdrop');
        const recipeModalTitle = document.getElementById('recipe-modal-title');
        const recipeModalBody = document.getElementById('recipe-modal-body');
        const btnCloseRecipe = document.getElementById('btn-close-recipe');
        const btnTtsToggle = document.getElementById('btn-tts-toggle');

        const btnVoiceRecipe = document.getElementById('btn-voice-recipe');
        const autoPlayToggle = document.getElementById('auto-play-toggle');

        const noRecipePopup = document.getElementById('no-recipe-popup');
        let noRecipePopupTimer = null;

        let currentSelectedMenu = null; // {id, name}
        let currentSelectedCard = null;

        // TTS ON/OFF ìƒíƒœ (ê¸°ë³¸ OFF)
        let ttsEnabled = false;

        // ìë™ì¬ìƒ ìƒíƒœ (ì²´í¬ ì‹œ: step1ë¶€í„° TTS â†’ íƒ€ì´ë¨¸ â†’ ë‹¤ìŒ ìŠ¤í… ìë™)
        let autoPlayEnabled = false;

        // í˜„ì¬ ì„ íƒëœ ìŠ¤í… ì¸ë±ìŠ¤
        let currentStepIndex = 0;

        // ê° ìŠ¤í… íƒ€ì´ë¨¸ìš© (í•œ ë²ˆì— í•˜ë‚˜ë§Œ ë™ì‘)
        let stepTimerIntervalId = null;
        let stepTimerRemaining = 0;

        // íƒ€ì´ë¨¸ ì›í˜• ì§„í–‰ë°” ê³µí†µ ìƒìˆ˜
        const TIMER_RADIUS = 18;
        const TIMER_CIRCUMFERENCE = 2 * Math.PI * TIMER_RADIUS;

        // ìŒì„± ì¸ì‹ ìƒíƒœ
        let recognition = null;
        let recognizing = false;
        let voiceSessionActive = false;

        // ====== ìœ í‹¸: í•œê¸€ í…ìŠ¤íŠ¸ ì •ê·œí™” ======
        function normalizeKoreanText(text) {
            if (!text) return '';
            return text
                    .toLowerCase()
                    .replace(/\s+/g, '')
                    .replace(/[.!?,~\-\_]/g, '');
        }

        // ====== ìˆ«ì ì¶”ì¶œ (ì˜ˆ: "10ë²ˆ ë ˆì‹œí”¼", "10ë²ˆ ë³´ì—¬ì¤˜") ======
        function extractNumberFromText(text) {
            if (!text) return null;
            const match = text.match(/(\d{1,4})\s*(ë²ˆ|ë²ˆë ˆì‹œí”¼|ë²ˆë ˆì‹œí”¼ì¢€|ë²ˆë³´ì—¬ì¤˜|ë²ˆë³´ì—¬|ë²ˆìœ¼ë¡œ|ë²ˆì¢€)?/);
            if (match && match[1]) {
                const num = parseInt(match[1], 10);
                if (!isNaN(num)) return num;
            }
            return null;
        }

        // ====== TTS(ìŒì„± í•©ì„±) ======
        function speakText(text, onEnd) {
            if (!('speechSynthesis' in window)) {
                alert('ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ìŒì„± í•©ì„±ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }
            if (!text || !text.trim()) return;

            window.speechSynthesis.cancel();

            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'ko-KR';

            const voices = window.speechSynthesis.getVoices();
            const koVoice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('ko'));
            if (koVoice) {
                utter.voice = koVoice;
            }

            if (typeof onEnd === 'function') {
                utter.onend = function () {
                    onEnd();
                };
            }

            window.speechSynthesis.speak(utter);
        }

        function stopSpeak() {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }
        }

        function updateSelectedCount() {
            selectedCountSpan.textContent = currentSelectedMenu ? '1' : '0';
        }

        function clearAllSelections() {
            cards.forEach(c => c.classList.remove('selected'));
            currentSelectedMenu = null;
            currentSelectedCard = null;
            updateSelectedCount();
        }

        function updateTtsToggleVisual() {
            if (!btnTtsToggle) return;
            btnTtsToggle.classList.toggle('on', ttsEnabled);
            btnTtsToggle.classList.toggle('off', !ttsEnabled);
            btnTtsToggle.textContent = ttsEnabled ? 'ğŸ”Š' : 'ğŸ”ˆ';
            btnTtsToggle.title = ttsEnabled
                    ? 'ìë™ ìŒì„± ì•ˆë‚´ ë„ê¸°'
                    : 'ìë™ ìŒì„± ì•ˆë‚´ ì¼œê¸°';
        }

        function updateMicVisual(isOn) {
            if (!btnVoiceRecipe) return;
            btnVoiceRecipe.classList.toggle('listening', !!isOn);
            btnVoiceRecipe.title = isOn
                    ? "ìŒì„±ì¸ì‹ ì¼œì§ Â· 'í—¬ë¦¬ì•¼ / ë ˆì‹œí”¼ ì´ë¦„ / ë²ˆí˜¸ / ë‹¤ìŒ / ê·¸ë§Œ / ìŒì„±ì¸ì‹ ê·¸ë§Œ'ì„ ë§í•´ë³´ì„¸ìš”."
                    : "ìŒì„±ì¸ì‹ êº¼ì§ Â· ëˆ„ë¥´ê³  'í—¬ë¦¬ì•¼ / ë ˆì‹œí”¼ ì´ë¦„ / ë²ˆí˜¸ / ë‹¤ìŒ / ê·¸ë§Œ / ìŒì„±ì¸ì‹ ê·¸ë§Œ'ì„ ë§í•´ë³´ì„¸ìš”.";
        }

        function isRecipeModalOpen() {
            return recipeModal.classList.contains('show');
        }

        function getStepDivs() {
            return recipeModalBody.querySelectorAll('.recipe-step');
        }

        function getSelectedStepDiv() {
            return recipeModalBody.querySelector('.recipe-step.step-selected');
        }

        // ====== ìŠ¤í… íƒ€ì´ë¨¸ ì‹œê° ì´ˆê¸°í™” ======
        function initStepTimerVisual(stepDiv) {
            const time = parseInt(stepDiv.dataset.stepTime || '0', 10);
            const circle = stepDiv.querySelector('.step-timer-progress-circle');
            const valueEl = stepDiv.querySelector('.step-timer-value');

            if (!circle || !valueEl) return;

            circle.style.strokeDasharray = TIMER_CIRCUMFERENCE;
            // 0 offset = ê½‰ ì°¬ ì› (ëŒ€ê¸° ìƒíƒœ)
            circle.style.strokeDashoffset = 0;

            valueEl.textContent = (time && time > 0) ? String(time) : '-';
        }

        // í˜„ì¬ ë™ì‘ ì¤‘ì¸ íƒ€ì´ë¨¸ ì¤‘ë‹¨ + í˜„ì¬ ì„ íƒ ìŠ¤í…ì˜ íƒ€ì´ë¨¸ í‘œì‹œ ë¦¬ì…‹
        function stopStepCountdown(resetVisual) {
            if (stepTimerIntervalId) {
                clearInterval(stepTimerIntervalId);
                stepTimerIntervalId = null;
            }
            if (resetVisual) {
                const s = getSelectedStepDiv();
                if (s) {
                    initStepTimerVisual(s);
                }
            }
        }

        // íŠ¹ì • ìŠ¤í…ì— ëŒ€í•´ íƒ€ì´ë¨¸ ì‹œì‘ (time ì´ˆ) â†’ ëë‚˜ë©´ onDone í˜¸ì¶œ
        function startStepCountdown(stepDiv, time, onDone) {
            if (!time || time <= 0) {
                if (typeof onDone === 'function') {
                    onDone();
                }
                return;
            }

            stopStepCountdown(false);

            const circle = stepDiv.querySelector('.step-timer-progress-circle');
            const valueEl = stepDiv.querySelector('.step-timer-value');
            if (!circle || !valueEl) {
                if (typeof onDone === 'function') {
                    onDone();
                }
                return;
            }

            let total = time;
            let remaining = time;
            stepTimerRemaining = remaining;

            circle.style.strokeDasharray = TIMER_CIRCUMFERENCE;
            circle.style.strokeDashoffset = 0;
            valueEl.textContent = String(remaining);

            stepTimerIntervalId = setInterval(function () {
                remaining--;
                stepTimerRemaining = remaining;

                if (remaining <= 0) {
                    remaining = 0;
                    valueEl.textContent = '0';
                    // 100% ì†Œì§„ â†’ ì „ì²´ ë‘˜ë ˆë§Œí¼ offset
                    circle.style.strokeDashoffset = TIMER_CIRCUMFERENCE;
                    clearInterval(stepTimerIntervalId);
                    stepTimerIntervalId = null;

                    if (typeof onDone === 'function') {
                        onDone();
                    }
                } else {
                    valueEl.textContent = String(remaining);
                    const ratio = 1 - (remaining / total);
                    circle.style.strokeDashoffset = TIMER_CIRCUMFERENCE * ratio;
                }
            }, 1000);
        }

        // force=true: TTS ìƒíƒœì™€ ìƒê´€ ì—†ì´ ì½ê¸°
        function speakCurrentSelectedStep(force, onEnd) {
            const selectedStep = getSelectedStepDiv();
            if (!selectedStep) return;

            const textNode = selectedStep.querySelector('.step-text');
            if (!textNode) return;

            const text = textNode.textContent.trim();
            if (!text) return;

            if (!force && !ttsEnabled) return;

            speakText(text, onEnd);
        }

        // index ë²ˆì§¸ ìŠ¤í… ì„ íƒ + TTS + (ìë™ì¬ìƒì´ë©´) íƒ€ì´ë¨¸ â†’ ë‹¤ìŒ ìŠ¤í…
        function goToStep(index, options) {
            options = options || {};
            const forceSpeak = !!options.forceSpeak;
            const fromAuto = !!options.fromAuto;

            const steps = getStepDivs();
            if (!steps.length) {
                stopStepCountdown(true);
                return;
            }

            if (index < 0 || index >= steps.length) {
                // ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ìë™ì¬ìƒ ì¢…ë£Œ
                stopStepCountdown(true);
                return;
            }

            // ì´ì „ íƒ€ì´ë¨¸ ì •ë¦¬
            stopStepCountdown(false);

            // ì„ íƒ ìƒíƒœ ê°±ì‹ 
            steps.forEach(s => s.classList.remove('step-selected'));
            const target = steps[index];
            target.classList.add('step-selected');
            currentStepIndex = index;

            // ì´ ìŠ¤í…ì˜ ê¸°ë³¸ íƒ€ì´ë¨¸ í‘œì‹œ ì´ˆê¸°í™”
            initStepTimerVisual(target);

            const shouldAutoPlay = autoPlayEnabled && isRecipeModalOpen();

            const afterSpeak = function () {
                if (!shouldAutoPlay) {
                    // ìë™ì¬ìƒ ì•„ë‹ˆë©´ íƒ€ì´ë¨¸ë„ ì•ˆ ëŒë¦¬ê³  ë
                    return;
                }

                const time = parseInt(target.dataset.stepTime || '0', 10);
                if (!time || time <= 0) {
                    // ì‹œê°„ ì •ë³´ ì—†ìœ¼ë©´ ë°”ë¡œ ë‹¤ìŒ ìŠ¤í…
                    goToStep(index + 1, {forceSpeak: true, fromAuto: true});
                    return;
                }

                startStepCountdown(target, time, function () {
                    if (!autoPlayEnabled || !isRecipeModalOpen()) {
                        stopStepCountdown(true);
                        return;
                    }
                    goToStep(index + 1, {forceSpeak: true, fromAuto: true});
                });
            };

            speakCurrentSelectedStep(forceSpeak || fromAuto, afterSpeak);
        }

        // "ë‹¤ìŒ" ëª…ë ¹ / ë²„íŠ¼ì—ì„œ í˜¸ì¶œ (fromVoiceCommand = trueë©´ íƒ€ì´ë¨¸/ìŒì„± ê°•ì œ ì¢…ë£Œ)
        function moveToNextStepAndSpeak(fromVoiceCommand) {
            const steps = getStepDivs();
            if (!steps.length) return;

            let idx = currentStepIndex || 0;
            if (!steps[idx] || !steps[idx].classList.contains('step-selected')) {
                idx = 0;
            } else {
                idx = Math.min(idx + 1, steps.length - 1);
            }

            if (fromVoiceCommand) {
                stopSpeak();
                stopStepCountdown(true);
            }

            goToStep(idx, {forceSpeak: true, fromAuto: autoPlayEnabled});
        }

        function stopAutoPlay() {
            stopStepCountdown(true);
        }

        // ğŸ”¥ DTO(steps + stepTimes) ë¥¼ ëª¨ë‹¬ìš© êµ¬ì¡°ë¡œ ë Œë”ë§
        function buildStepsFromCard(recipeId) {
            const container = document.getElementById('recipe-steps-' + recipeId);
            recipeModalBody.innerHTML = '';

            if (!container) {
                recipeModalBody.innerHTML =
                        '<p class="text-muted small mb-0">ë“±ë¡ëœ ìŠ¤í…ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            const stepTextNodes = container.querySelectorAll('.recipe-step-text');
            const stepTimeNodes = container.querySelectorAll('.recipe-step-time');

            if (stepTextNodes.length === 0) {
                recipeModalBody.innerHTML =
                        '<p class="text-muted small mb-0">ë“±ë¡ëœ ìŠ¤í…ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            stepTextNodes.forEach((stepNode, index) => {
                const text = (stepNode.textContent || '').trim();

                // ê°™ì€ ì¸ë±ìŠ¤ì˜ stepTime ê°€ì ¸ì˜¤ê¸°
                let time = 0;
                if (stepTimeNodes.length > index) {
                    const raw = (stepTimeNodes[index].textContent || '').trim();
                    const parsed = parseInt(raw, 10);
                    if (!isNaN(parsed) && parsed > 0) {
                        time = parsed;
                    }
                }

                const div = document.createElement('div');
                div.className = 'recipe-step';
                // ì´ ìŠ¤í…ì˜ ì‹œê°„(ì´ˆ)ì„ dataset ì— ì €ì¥
                div.dataset.stepTime = String(time || 0);

                // ê³„ë‹¨ íš¨ê³¼ìš© margin-left (ì „ì²´ ë°•ìŠ¤ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë°€ì–´ì¤Œ)
                const offset = index * 24;
                div.style.marginLeft = offset + 'px';

                // ì™¼ìª½(ì¸ë±ìŠ¤ + í…ìŠ¤íŠ¸)
                const main = document.createElement('div');
                main.className = 'step-main';

                const idxSpan = document.createElement('span');
                idxSpan.className = 'step-index';
                idxSpan.textContent = 'Step ' + (index + 1) + '.';

                const textSpan = document.createElement('span');
                textSpan.className = 'step-text';
                textSpan.textContent = text || 'ë‚´ìš© ì—†ìŒ';

                main.appendChild(idxSpan);
                main.appendChild(textSpan);

                // ì˜¤ë¥¸ìª½ ì›í˜• íƒ€ì´ë¨¸
                const timer = document.createElement('div');
                timer.className = 'step-timer';

                timer.innerHTML = `
                    <svg class="step-timer-svg" viewBox="0 0 48 48">
                        <circle class="step-timer-bg-circle" cx="24" cy="24" r="18"></circle>
                        <circle class="step-timer-progress-circle" cx="24" cy="24" r="18"></circle>
                    </svg>
                    <span class="step-timer-value"></span>
                `;

                div.appendChild(main);
                div.appendChild(timer);
                recipeModalBody.appendChild(div);

                // íƒ€ì´ë¨¸ ì‹œê° ì´ˆê¸°í™”
                initStepTimerVisual(div);
            });

            const stepDivs = getStepDivs();
            if (!stepDivs.length) return;

            // ì²« ë²ˆì§¸ ìŠ¤í… ì„ íƒ
            stepDivs[0].classList.add('step-selected');
            currentStepIndex = 0;

            // í´ë¦­ ì‹œ: í•´ë‹¹ ìŠ¤í…ìœ¼ë¡œ ì´ë™ + (ttsEnabledë©´) ì½ê¸°
            stepDivs.forEach((step, idx) => {
                step.addEventListener('click', () => {
                    stopSpeak();
                    stopStepCountdown(true);
                    goToStep(idx, {forceSpeak: false, fromAuto: autoPlayEnabled});
                });
            });
        }

        function openRecipeModal(menu) {
            recipeModalTitle.textContent = '#' + menu.id + ' ' + menu.name + ' ë ˆì‹œí”¼';

            stopSpeak();
            stopAutoPlay();

            // ìë™ì¬ìƒ ì¼œì ¸ ìˆìœ¼ë©´ ìŠ¤í”¼ì»¤ë„ ìë™ ON
            if (autoPlayEnabled) {
                ttsEnabled = true;
            }
            updateTtsToggleVisual();

            buildStepsFromCard(menu.id);
            recipeModal.classList.add('show');

            // ìë™ì¬ìƒ ì¼œì ¸ ìˆìœ¼ë©´ Step1ë¶€í„° ìë™ ì§„í–‰
            if (autoPlayEnabled) {
                goToStep(0, {forceSpeak: true, fromAuto: true});
            }
        }

        function closeRecipeModal() {
            recipeModal.classList.remove('show');
            stopSpeak();
            stopAutoPlay();
        }

        function showNoRecipePopup() {
            if (!noRecipePopup) return;
            if (noRecipePopupTimer) {
                clearTimeout(noRecipePopupTimer);
                noRecipePopupTimer = null;
            }
            noRecipePopup.textContent = 'ë ˆì‹œí”¼ê°€ ì—†ìŠµë‹ˆë‹¤.';
            noRecipePopup.classList.add('show');
            noRecipePopupTimer = setTimeout(() => {
                noRecipePopup.classList.remove('show');
            }, 2000);
        }

        function handleCardSelect(card, options) {
            const id = card.dataset.recipeId;
            const name = card.dataset.recipeName;
            const fromVoice = options && options.fromVoice;

            if (currentSelectedCard === card && !fromVoice) {
                clearAllSelections();
                closeRecipeModal();
                return;
            }

            clearAllSelections();

            card.classList.add('selected');
            currentSelectedMenu = {id, name};
            currentSelectedCard = card;

            updateSelectedCount();
            openRecipeModal(currentSelectedMenu);
        }

        // ====== ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ======
        function initRecognition() {
            if (recognition) return recognition;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ìŒì„± ì¸ì‹ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n(Chrome / Edge ìµœì‹  ë²„ì „ ê¶Œì¥)');
                return null;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'ko-KR';
            recognition.interimResults = false;
            recognition.maxAlternatives = 3;

            recognition.onresult = function (event) {
                const rawTranscript = (event.results[0][0].transcript || '').trim();
                console.log('ìŒì„± ì¸ì‹ ê²°ê³¼:', rawTranscript);

                let normTranscript = normalizeKoreanText(rawTranscript);

                // "í—¬ë¦¬ì•¼" ë‹¨ë… í˜¸ì¶œ: ì•ˆë‚´ë§Œ
                if (normTranscript === 'í—¬ë¦¬ì•¼') {
                    speakText('ë ˆì‹œí”¼ ë²ˆí˜¸ë¥¼ ë¶ˆëŸ¬ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´, ì‹­ë²ˆ, ì‹­ë²ˆ ë ˆì‹œí”¼ ë¼ê³  ë§í•´ë³´ì„¸ìš”.');
                    return;
                }

                // ì²˜ë¦¬ìš© í…ìŠ¤íŠ¸
                let processedRaw = rawTranscript;
                let processedNorm = normTranscript;

                // "í—¬ë¦¬ì•¼ ~~~" í˜•íƒœë©´ í˜¸ì¶œì–´ ì œê±° í›„ ì²˜ë¦¬
                if (normTranscript.startsWith('í—¬ë¦¬ì•¼')) {
                    processedRaw = rawTranscript.replace(/^\s*í—¬ë¦¬ì•¼[\s,]*/, '');
                    processedNorm = normalizeKoreanText(processedRaw);
                }

                if (!processedNorm) return;

                // "ìŒì„±ì¸ì‹ ê·¸ë§Œ" â†’ ì¸ì‹ ì„¸ì…˜ ì™„ì „ ì¢…ë£Œ + TTS ì¤‘ì§€
                if (processedNorm.includes('ìŒì„±ì¸ì‹ê·¸ë§Œ')) {
                    stopVoiceSession();
                    stopSpeak();
                    stopStepCountdown(true);
                    return;
                }

                // "ê·¸ë§Œ" â†’ ëª¨ë‹¬ë§Œ ë‹«ê¸° (ì¸ì‹ì€ ìœ ì§€)
                if (processedNorm.includes('ê·¸ë§Œ')) {
                    if (isRecipeModalOpen()) {
                        closeRecipeModal();
                    }
                    return;
                }

                // "ë‹¤ìŒ" â†’ ë‹¤ìŒ ìŠ¤í… (í˜„ì¬ TTS/íƒ€ì´ë¨¸ ì¤‘ì§€ í›„)
                if (processedNorm.includes('ë‹¤ìŒ')) {
                    if (isRecipeModalOpen()) {
                        moveToNextStepAndSpeak(true);
                    }
                    return;
                }

                // ìˆ«ì ê¸°ë°˜ ë ˆì‹œí”¼ ì„ íƒ
                const num = extractNumberFromText(processedRaw);
                if (num !== null) {
                    const cardById = document.querySelector('.menu-card[data-recipe-id="' + num + '"]');
                    if (cardById) {
                        handleCardSelect(cardById, {fromVoice: true});
                        return;
                    }
                }

                // ì´ë¦„ ê¸°ë°˜ ë ˆì‹œí”¼ ì„ íƒ
                let bestCard = null;
                let bestScore = 0;

                function tryMatch(withNormTranscript) {
                    cards.forEach(card => {
                        const name = card.dataset.recipeName || '';
                        const normName = normalizeKoreanText(name);
                        if (!normName) return;

                        if (withNormTranscript.includes(normName) || normName.includes(withNormTranscript)) {
                            const score = normName.length;
                            if (score > bestScore) {
                                bestScore = score;
                                bestCard = card;
                            }
                        }
                    });
                }

                // 1ì°¨: processedNorm ê¸°ì¤€
                tryMatch(processedNorm);

                // 2ì°¨: ê³µë°± ì œê±°ëœ ì›ë¬¸ ê¸°ì¤€
                if (!bestCard) {
                    const joined = processedRaw.replace(/\s+/g, '');
                    const joinedNorm = normalizeKoreanText(joined);
                    if (joinedNorm && joinedNorm !== processedNorm) {
                        tryMatch(joinedNorm);
                    }
                }

                if (bestCard) {
                    handleCardSelect(bestCard, {fromVoice: true});
                } else {
                    showNoRecipePopup();
                }
            };

            recognition.onerror = function (event) {
                console.error('ìŒì„± ì¸ì‹ ì˜¤ë¥˜:', event.error);
                recognizing = false;
                if (!voiceSessionActive) {
                    updateMicVisual(false);
                }
            };

            recognition.onend = function () {
                recognizing = false;
                if (voiceSessionActive && recognition) {
                    try {
                        recognizing = true;
                        recognition.start();
                    } catch (e) {
                        console.error('ìŒì„± ì¸ì‹ ì¬ì‹œì‘ ì‹¤íŒ¨:', e);
                        recognizing = false;
                        voiceSessionActive = false;
                        updateMicVisual(false);
                    }
                } else {
                    updateMicVisual(false);
                }
            };

            return recognition;
        }

        function startVoiceSession() {
            const rec = initRecognition();
            if (!rec) return;

            if (voiceSessionActive && recognizing) {
                return;
            }

            voiceSessionActive = true;
            updateMicVisual(true);

            if (!recognizing) {
                recognizing = true;
                try {
                    rec.start();
                } catch (e) {
                    console.error('ìŒì„± ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨:', e);
                    recognizing = false;
                    voiceSessionActive = false;
                    updateMicVisual(false);
                }
            }
        }

        function stopVoiceSession() {
            voiceSessionActive = false;
            if (recognition && recognizing) {
                try { recognition.stop(); } catch (e) {}
            }
            recognizing = false;
            updateMicVisual(false);
        }

        function toggleVoiceRecognition() {
            if (voiceSessionActive) {
                stopVoiceSession();
            } else {
                startVoiceSession();
            }
        }

        // ì¹´ë“œ í´ë¦­ â†’ ì„ íƒ
        cards.forEach(card => {
            card.addEventListener('click', () => {
                handleCardSelect(card, {fromVoice: false});
            });
        });

        // ìƒë‹¨ ë§ˆì´í¬ ë²„íŠ¼
        if (btnVoiceRecipe) {
            btnVoiceRecipe.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleVoiceRecognition();
            });
        }

        // ìë™ì¬ìƒ í† ê¸€
        if (autoPlayToggle) {
            autoPlayEnabled = autoPlayToggle.checked;
            autoPlayToggle.addEventListener('change', () => {
                autoPlayEnabled = autoPlayToggle.checked;
                if (!autoPlayEnabled) {
                    stopAutoPlay();
                } else {
                    // ëª¨ë‹¬ì´ ì—´ë ¤ ìˆë‹¤ë©´ í˜„ì¬/ì²« ìŠ¤í…ë¶€í„° ìë™ì¬ìƒ ì‹œì‘ + TTS ON
                    if (isRecipeModalOpen()) {
                        ttsEnabled = true;
                        updateTtsToggleVisual();
                        const steps = getStepDivs();
                        if (steps.length > 0) {
                            const idx = steps[currentStepIndex]
                                    ? currentStepIndex
                                    : 0;
                            goToStep(idx, {forceSpeak: true, fromAuto: true});
                        }
                    }
                }
            });
        }

        // ëª¨ë‹¬ ë‹«ê¸°
        if (btnCloseRecipe) {
            btnCloseRecipe.addEventListener('click', () => {
                closeRecipeModal();
            });
        }

        // ë°°ê²½ í´ë¦­ â†’ ë‹«ê¸°
        if (recipeModalBackdrop) {
            recipeModalBackdrop.addEventListener('click', () => {
                closeRecipeModal();
            });
        }

        // ESC â†’ ë‹«ê¸°
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeRecipeModal();
            }
        });

        // ğŸ”Š TTS í† ê¸€ ë²„íŠ¼ í´ë¦­
        if (btnTtsToggle) {
            btnTtsToggle.addEventListener('click', () => {
                ttsEnabled = !ttsEnabled;
                updateTtsToggleVisual();

                if (ttsEnabled) {
                    // í˜„ì¬ ì„ íƒëœ ìŠ¤í…ì´ ìˆìœ¼ë©´ ë°”ë¡œ ì½ì–´ì¤Œ (ìë™ì¬ìƒì€ ì•„ë‹˜)
                    speakCurrentSelectedStep(false);
                } else {
                    stopSpeak();
                }
            });
        }

        // ì´ˆê¸° ìƒíƒœ
        updateSelectedCount();
        updateTtsToggleVisual();
        updateMicVisual(false);

    })();
</script>

{{>layouts/footer}}
