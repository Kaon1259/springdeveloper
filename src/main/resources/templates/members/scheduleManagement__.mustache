{{>layouts/header}}

<main class="container my-4">
    <div class="row g-3">

        <!-- ============ 좌측: 아르바이트 상태별 보기 ============ -->
        <div class="col-12 col-lg-4">
            <div class="d-grid gap-3 sticky-lg-top" style="top:12px;">

                <!-- 상태별 보기 -->
                <div class="card">
                    <div class="card-header fw-bold d-flex align-items-center justify-content-between">
                        <span>아르바이트 상태별 보기</span>
                        <span id="statusCountBadge" class="badge bg-secondary">0명</span>
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <label class="form-label small text-muted" for="statusSelect">상태</label>
                            <select id="statusSelect" class="form-select">
                                <option value="WORKING" selected>근무중</option>
                                <option value="WAITING">시작전</option>
                                <option value="RESTING">휴식중</option>
                                <option value="PAUSED">일시중지</option>
                                <option value="RESIGNED">퇴사</option>
                            </select>
                            <div class="form-text">상태를 바꾸면 해당 상태인 아르바이트생이 아래에 표시됩니다.</div>
                        </div>

                        <!-- 아르바이트 칩 목록 -->
                        <div id="memberPills" class="d-flex flex-wrap gap-2"></div>

                        <div class="small text-muted mt-3">
                            * 색상은 사람마다 고유하게 지정됩니다. 칩을 클릭하여 선택하세요.
                        </div>
                    </div>
                </div>

                <!-- 간단 범례 -->
                <div class="card">
                    <div class="card-body d-flex align-items-center gap-3">
                        <span class="legend legend-plan"></span><span class="small">계획(주간 템플릿)</span>
                        <span class="legend legend-actual"></span><span class="small">저장된 일정</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ 우측: 생성/달력 ============ -->
        <div class="col-12 col-lg-8">

            <!-- 일정 생성 컨트롤 -->
            <div class="card mb-2">
                <div class="card-header fw-bold d-flex justify-content-between align-items-center">
          <span>
            일정 생성(주간 템플릿 → 월별 일정)
            <small id="selectedMemberLabel" class="text-muted ms-2">[선택된 근로자: 없음]</small>
          </span>
                    <span id="selectedMemberStatus" class="badge bg-secondary d-none">-</span>
                </div>
                <div class="card-body">
                    <div class="row g-3">
                        <div class="col-12 col-md-4">
                            <label class="form-label small text-muted">시작 월</label>
                            <input id="startMonth" type="month" class="form-control" />
                            <div class="form-text">아래 달력도 이 월 기준으로 표시됩니다.</div>
                        </div>
                        <div class="col-12 col-md-4">
                            <label class="form-label small text-muted">개월 수</label>
                            <select id="monthsCount" class="form-select">
                                <option value="1" selected>1개월</option>
                                <option value="2">2개월</option>
                                <option value="3">3개월</option>
                                <option value="4">4개월</option>
                                <option value="5">5개월</option>
                                <option value="6">6개월</option>
                                <option value="12">12개월</option>
                            </select>
                            <div class="form-text">생성은 시작월~선택 개월만큼 저장됩니다.</div>
                        </div>
                        <div class="col-12 col-md-4 d-flex align-items-end gap-2">
                            <button id="btnPreview" class="btn btn-outline-primary w-50" type="button" disabled>미리보기</button>
                            <button id="btnSave" class="btn btn-primary w-50" type="button" disabled>저장</button>
                        </div>
                    </div>
                    <div id="alertArea" class="mt-3"></div>
                </div>
            </div>

            <!-- 선택 월 실제 일정(저장된 스케줄) 달력 -->
            <div class="card">
                <div class="card-header fw-bold d-flex align-items-center justify-content-between">
                    <span>선택 월 실제 일정</span>
                    <div class="d-flex align-items-center gap-2">
                        <button id="btnMonthPrev" class="btn btn-sm btn-outline-secondary">◀ 이전 달</button>
                        <span id="monthRangeLabel" class="small text-muted">0000.00.01 ~ 00.00</span>
                        <button id="btnMonthThis" class="btn btn-sm btn-outline-secondary">이번 달</button>
                        <button id="btnMonthNext" class="btn btn-sm btn-outline-secondary">다음 달 ▶</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="calendar-grid" id="calendarGrid"></div>
                    <div class="mt-3">
                        <div class="d-flex justify-content-between">
                            <div class="small text-muted">월 합계(실근무)</div>
                            <div class="fw-semibold" id="monthActualTotalCell">0시간</div>
                        </div>
                    </div>
                    <div class="small text-muted mt-2">
                        * 날짜 칸에는 저장된 일정(실제)이 칩으로 표시됩니다.
                    </div>
                    <!-- 내부 상태 보관(표시안함) -->
                    <span id="monthLabel" class="d-none">0000-00-01</span>
                </div>
            </div>

        </div>
    </div>
</main>

<style>
    .legend { display:inline-block; width:14px; height:14px; border-radius:3px; border:1px solid #ddd; vertical-align:middle; }
    .legend-plan { background: rgba(13,110,253,.25); border-color: rgba(13,110,253,.45); }
    .legend-actual { background: rgba(25,135,84,.25); border-color: rgba(25,135,84,.40); }

    /* 멤버 칩 */
    .pill {
        display:inline-flex; align-items:center; gap:8px;
        padding:6px 10px; border:1px solid #e9ecef; border-radius:999px;
        cursor:pointer; user-select:none; background:#fff;
    }
    .pill .dot { width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,.1); }
    .pill.active { outline:2px solid rgba(13,110,253,.35); outline-offset:2px; }
    .pill .name { font-weight:600; }
    .pill .status { font-size:.8rem; color:#6c757d; }

    /* 달력 */
    .calendar-grid { display:grid; grid-template-columns:repeat(7,1fr); gap:8px; }
    .calendar-grid .dow { text-align:center; font-weight:600; color:#6c757d; padding:6px 0; border-bottom:1px dashed #e9ecef; }
    .calendar-grid .cell { border:1px solid #e9ecef; border-radius:10px; padding:8px; min-height:120px; background:#fff; display:flex; flex-direction:column; gap:6px; }
    .cell .date-head { display:flex; align-items:center; justify-content:space-between; font-weight:600; font-size:.95rem; }
    .cell .date-head .dow-mini { color:#6c757d; font-weight:500; font-size:.85rem; }
    .cell .segments { display:flex; flex-wrap:wrap; gap:6px; }
    .cell .day-total { margin-top:auto; text-align:right; font-size:.875rem; color:#212529; }
    .cell.muted { background:#fcfcfc; color:#96a0aa; }
    .cell.today { outline:2px solid #51cf66; outline-offset:2px; }

    .chip { display:inline-flex; align-items:center; gap:6px; padding:2px 6px; border:1px solid #dee2e6; border-radius:999px; background:#fff; }
</style>

<script id="membersData" type="application/json">
{{{membersJson}}}
</script>

<script>
    (function(){
        // ===== DOM =====
        const statusSelect = document.getElementById('statusSelect');
        const memberPills = document.getElementById('memberPills');
        const statusCountBadge = document.getElementById('statusCountBadge');

        const selectedMemberLabel = document.getElementById('selectedMemberLabel');
        const selectedMemberStatus = document.getElementById('selectedMemberStatus');

        const startMonth = document.getElementById('startMonth');
        const monthsCount = document.getElementById('monthsCount');
        const btnPreview = document.getElementById('btnPreview');
        const btnSave = document.getElementById('btnSave');
        const alertArea = document.getElementById('alertArea');

        const calendarGrid = document.getElementById('calendarGrid');
        const monthLabel = document.getElementById('monthLabel');
        const monthRangeLabel = document.getElementById('monthRangeLabel');
        const btnMonthPrev = document.getElementById('btnMonthPrev');
        const btnMonthThis = document.getElementById('btnMonthThis');
        const btnMonthNext = document.getElementById('btnMonthNext');
        const monthActualTotalCell = document.getElementById('monthActualTotalCell');

        const API_ENDPOINT = '/api/schedule/work'; // ✅ 엔드포인트만 바꿔 쓰세요

        // ===== 데이터 =====
        let allMembers = [];
        try { allMembers = JSON.parse(document.getElementById('membersData').textContent || '[]'); } catch(e){ allMembers = []; }
        if(Array.isArray(allMembers) && allMembers.length>0){
            statusSelect.value = allMembers[0].status || 'WORKING';
        }

        let currentMember = null;
        let generatedItems = []; // 저장용 미리보기 결과 (원하면 유지)

        // 기본 시작월: 오늘 달
        const today = new Date();
        startMonth.value = `${today.getFullYear()}-${pad2(today.getMonth()+1)}`;

        // 초기 렌더
        renderMembersByStatus();
        updateSelectedMemberLabel(); // 초기 '없음' 상태
        attachHandlers();

        // ========== 이벤트 ==========
        function attachHandlers(){
            statusSelect.addEventListener('change', ()=>{
                renderMembersByStatus();
                // 멤버 변경되었으므로 선택 초기화
                //selectMember(null);
            });

            // 생성 관련
            btnPreview.addEventListener('click', onPreview);
            btnSave.addEventListener('click', onSave);

            // 달력 내비
            btnMonthPrev.addEventListener('click', (e)=>{ e.preventDefault(); navigateMonth(-1); });
            btnMonthNext.addEventListener('click', (e)=>{ e.preventDefault(); navigateMonth(+1); });
            btnMonthThis.addEventListener('click', (e)=>{ e.preventDefault(); goToThisMonth(); });

            // 시작월 변경 시 달력 갱신
            startMonth.addEventListener('change', ()=>{
                if(currentMember) renderMonthCalendar(currentMember, getCurrentMonthStart());
            });
        }

        // ========== 상태별 멤버 렌더 ==========
        function renderMembersByStatus(){
            const status = statusSelect.value;
            const filtered = (allMembers||[]).filter(m=>m.status===status);

            statusCountBadge.textContent = `${filtered.length}명`;
            memberPills.innerHTML = '';

            if(!filtered.length){
                memberPills.innerHTML = `<div class="text-muted small">해당 상태의 아르바이트생이 없습니다.</div>`;
                return;
            }

            filtered.forEach(m=>{
                const color = colorForMember(m);
                const pill = document.createElement('button');
                pill.type = 'button';
                pill.className = 'pill';
                pill.dataset.memberId = String(m.id);
                pill.innerHTML = `
        <span class="dot" style="background:${color}"></span>
        <span class="name">${escapeHtml(m.name ?? '-')}</span>
        <span class="status">(${escapeHtml(m.gender ?? '-')})</span>
      `;
                pill.addEventListener('click', ()=> selectMember(m));
                memberPills.appendChild(pill);
            });

            // 첫 사람 자동 선택(있다면)
            if(filtered.length>0){
                selectMember(filtered[0]);
            } else {
                selectMember(null);
            }
        }

        function selectMember(m){
            currentMember = m;

            // pill active 표시
            Array.from(memberPills.querySelectorAll('.pill')).forEach(el=>el.classList.remove('active'));
            if(m){
                const active = memberPills.querySelector(`.pill[data-member-id="${m.id}"]`);
                if(active) active.classList.add('active');
            }

            // 상단 라벨/배지
            updateSelectedMemberLabel();

            // 버튼 활성/비활성
            const enabled = !!currentMember;
            btnPreview.disabled = !enabled;
            btnSave.disabled = !enabled;

            // 달력 갱신
            if(currentMember){
                renderMonthCalendar(currentMember, getCurrentMonthStart());
            }else{
                clearCalendar();
            }

            // 미리보기 초기화
            generatedItems = [];
            clearAlert();
        }

        function updateSelectedMemberLabel(){
            if(!currentMember){
                selectedMemberLabel.textContent = '[선택된 근로자: 없음]';
                selectedMemberStatus.classList.add('d-none');
                selectedMemberStatus.textContent = '-';
                selectedMemberStatus.className = 'badge bg-secondary d-none';
            }else{
                selectedMemberLabel.textContent = `[선택된 근로자: ${currentMember.name ?? '-'}]`;
                const badgeMap={WORKING:'bg-success',WAITING:'bg-secondary',RESTING:'bg-info',PAUSED:'bg-warning',RESIGNED:'bg-danger'};
                selectedMemberStatus.classList.remove('d-none');
                selectedMemberStatus.textContent = currentMember.status || '-';
                selectedMemberStatus.className = `badge ${badgeMap[currentMember.status]||'bg-secondary'}`;
            }
        }

        // ========== 생성(미리보기/저장) ==========
        async function onPreview(){
            clearAlert();
            if(!currentMember){
                showAlert('근로자를 먼저 선택하세요.', 'warning');
                return;
            }
            const {fromDate, toDate} = getRange();
            generatedItems = buildItemsFromWeeklyTemplate(currentMember, fromDate, toDate);
            if(generatedItems.length===0){
                showAlert('생성된 일정이 없습니다. (주간 템플릿이 없거나, 범위 내 매칭이 없음)', 'secondary');
            }else{
                showAlert(`미리보기 완료: 총 ${generatedItems.length}개 구간이 생성될 예정입니다.`, 'info');
            }
        }

        async function onSave(){
            clearAlert();
            if(!currentMember){
                showAlert('근로자를 먼저 선택하세요.', 'warning');
                return;
            }
            if(!generatedItems || generatedItems.length===0){
                showAlert('저장할 일정이 없습니다. 먼저 미리보기를 실행하세요.', 'warning');
                return;
            }
            const {fromDate, toDate} = getRange();

            const payload = {
                memberId: currentMember.id,
                from: toIso(fromDate),
                to: toIso(toDate),
                items: generatedItems
                // overwrite: 필요 시 true/false 추가 가능
            };

            try{
                const url = `${API_ENDPOINT}/generate`;
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type':'application/json', 'Accept':'application/json'},
                    body: JSON.stringify(payload)
                });
                if(!resp.ok){
                    const text = await resp.text();
                    showAlert(`저장 실패: ${resp.status} ${text}`, 'danger');
                    return;
                }
                await resp.json().catch(()=>({}));
                showAlert('저장 완료! 아래 달력의 실제 일정이 갱신됩니다.', 'success');

                // 저장 후, 달력 갱신(시작월 기준)
                renderMonthCalendar(currentMember, getCurrentMonthStart());
            }catch(e){
                console.error(e);
                showAlert('저장 중 오류가 발생했습니다.', 'danger');
            }
        }

        function getRange(){
            const [y,m] = String(startMonth.value||'').split('-').map(n=>parseInt(n,10));
            const count = parseInt(monthsCount.value,10)||1;
            const fromDate = new Date(isNaN(y)?today.getFullYear():y, isNaN(m)?today.getMonth():m-1, 1);
            const toDate = new Date(fromDate.getFullYear(), fromDate.getMonth()+count, 0); // count개월 말일
            return { fromDate, toDate };
        }

        // 주간 템플릿 → 날짜별 아이템 생성
        function buildItemsFromWeeklyTemplate(member, fromDate, toDate){
            const weekly = getSchedules(member); // [{day:'MON', start:'10:00', end:'14:00'}, ...]
            if(!Array.isArray(weekly) || weekly.length===0) return [];

            const mapToJS={'SUN':0,'MON':1,'TUE':2,'WED':3,'THU':4,'FRI':5,'SAT':6};
            const dedupe = new Set();
            const items = [];

            for(let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate()+1)){
                const dow = d.getDay(); // 0~6
                const segs = weekly.filter(s => mapToJS[s.day] === dow);
                if(!segs.length) continue;
                const iso = toIso(d);

                segs.forEach(s=>{
                    const start = hmStr(s.start);
                    const end   = hmStr(s.end);
                    if(!isValidRange(start, end)) return;
                    const key = `${iso}|${start}|${end}`;
                    if(dedupe.has(key)) return;
                    dedupe.add(key);
                    items.push({date: iso, start, end, note: '자동 생성'});
                });
            }

            items.sort((a,b)=>{
                if(a.date !== b.date) return a.date < b.date ? -1 : 1;
                return a.start < b.start ? -1 : (a.start > b.start ? 1 : 0);
            });
            return items;
        }

        // ========== 달력(저장된 일정) ==========
        async function renderMonthCalendar(member, baseDate){
            const ms = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1);
            const me = new Date(baseDate.getFullYear(), baseDate.getMonth()+1, 0);
            const monthStartIso = toIso(ms), monthEndIso = toIso(me);

            // 라벨 즉시 갱신
            monthLabel.textContent = monthStartIso;
            const leftY = ms.getFullYear();
            const leftM = pad2(ms.getMonth()+1);
            const rightM = pad2(me.getMonth()+1);
            const rightD = pad2(me.getDate());
            monthRangeLabel.textContent = `${leftY}.${leftM}.01 ~ ${rightM}.${rightD}`;

            // 서버에서 실제 일정 조회
            let actualMap = {};
            try {
                const url = `${API_ENDPOINT}/${encodeURIComponent(member.id)}/${monthStartIso}/${monthEndIso}`;
                const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
                if (resp.ok) { actualMap = normalizeActualDays(await resp.json()); }
            } catch (e) { console.error(e); }

            // 렌더
            calendarGrid.innerHTML = '';
            const DOW_HEAD = ['일','월','화','수','목','금','토'];
            DOW_HEAD.forEach(label=>{
                const h = document.createElement('div');
                h.className = 'dow';
                h.textContent = label;
                calendarGrid.appendChild(h);
            });

            const todayIso = toIso(new Date());
            const firstDow = ms.getDay(); // 0=일
            for (let i=0;i<firstDow;i++){
                const blank = document.createElement('div');
                blank.className = 'cell muted';
                calendarGrid.appendChild(blank);
            }

            let monthMinutes = 0;
            for (let d = new Date(ms); d <= me; d.setDate(d.getDate()+1)) {
                const iso = toIso(d);
                const dow = d.getDay();
                const a = actualMap[iso] || {segments:[], minutes:0};
                monthMinutes += (a.minutes||0);

                const cell = document.createElement('div');
                cell.className = 'cell';
                if (iso === todayIso) cell.classList.add('today');

                const chipsHtml = (a.segments?.length)
                        ? a.segments.map(s=>chipHtml('#198754', s.start, s.end)).join(' ')
                        : '<span class="text-muted small">—</span>';

                cell.innerHTML = `
        <div class="date-head">
          <span>${d.getDate()}일</span>
          <span class="dow-mini">${DOW_HEAD[dow]}</span>
        </div>
        <div class="segments">${chipsHtml}</div>
        <div class="day-total">${formatMins(a.minutes||0)}</div>`;
                calendarGrid.appendChild(cell);
            }

            monthActualTotalCell.textContent = formatMins(monthMinutes);
        }

        function clearCalendar(){
            calendarGrid.innerHTML='';
            monthRangeLabel.textContent='0000.00.01 ~ 00.00';
            monthActualTotalCell.textContent='0시간';
        }

        function navigateMonth(offset){
            const curStart = getCurrentMonthStart(); // 현재 보이는 달의 1일(또는 startMonth 기반)
            const target = new Date(curStart.getFullYear(), curStart.getMonth()+offset, 1);
            if(currentMember){
                // 상단 startMonth UI도 함께 이동
                startMonth.value = `${target.getFullYear()}-${pad2(target.getMonth()+1)}`;
                renderMonthCalendar(currentMember, target);
            }
        }
        function goToThisMonth(){
            const tm = new Date();
            if(currentMember){
                startMonth.value = `${tm.getFullYear()}-${pad2(tm.getMonth()+1)}`;
                renderMonthCalendar(currentMember, new Date(tm.getFullYear(), tm.getMonth(), 1));
            }
        }
        function getCurrentMonthStart(){
            // startMonth 입력값 우선 사용
            const [y,m] = String(startMonth.value||'').split('-').map(n=>parseInt(n,10));
            const yv = isNaN(y)? today.getFullYear(): y;
            const mv = isNaN(m)? today.getMonth(): (m-1);
            return new Date(yv, mv, 1);
        }

        // ========== 공통 유틸 ==========
        function getSchedules(m){
            return Array.isArray(m?.schedules) ? m.schedules
                    : Array.isArray(m?.schedule)  ? m.schedule
                            : [];
        }
        function pad2(n){ return String(n).padStart(2,'0'); }
        function toIso(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
        function hmStr(v){
            if(typeof v === 'string' && /^\d{2}:\d{2}$/.test(v)) return v;
            if(typeof v === 'string' && /^\d{2}:\d{2}:\d{2}$/.test(v)) return v.slice(0,5);
            if(v && typeof v === 'object' && 'hour' in v && 'minute' in v) return `${pad2(v.hour)}:${pad2(v.minute)}`;
            try{
                const s = String(v);
                if(/^\d{1,2}:\d{1,2}/.test(s)){
                    const [h,m] = s.split(':').map(n=>parseInt(n,10));
                    return `${pad2(h)}:${pad2(m||0)}`;
                }
            }catch(_){}
            return '00:00';
        }
        function parseHm(hm){
            if(!hm||typeof hm!=='string') return {h:0,m:0};
            const [h,m] = hm.split(':').map(n=>parseInt(n,10));
            return {h:isNaN(h)?0:h, m:isNaN(m)?0:m};
        }
        function isValidRange(start, end){
            const s = parseHm(start), e = parseHm(end);
            const diff = (e.h*60+e.m) - (s.h*60+s.m);
            return diff > 0;
        }
        function diffMinutes(start, end){
            const s = parseHm(start), e = parseHm(end);
            return (e.h*60+e.m) - (s.h*60+s.m);
        }
        function formatMins(mins){
            const h=Math.floor(mins/60), m=mins%60;
            return m===0?`${h}시간`:`${h}시간 ${m}분`;
        }
        function chipHtml(color, start, end){
            return `<span class="chip"><span class="legend" style="background:${color};border-color:${color}"></span><span class="small">${start} ~ ${end}</span></span>`;
        }
        function colorForMember(m){
            const key = (m?.id!=null?String(m.id):(m?.name||'x'));
            const h = seededHash(key)%360, s=65, l=55;
            return hslToHex(h,s,l);
        }
        function seededHash(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0; } return h>>>0; }
        function hslToHex(h,s,l){
            s/=100; l/=100;
            const k=n=>(n+h/30)%12, a=s*Math.min(l,1-l);
            const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
            const toHex=x=>Math.round(255*x).toString(16).padStart(2,'0');
            return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
        }
        function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

        function normalizeActualDays(apiData){
            const map = {};
            const arr = Array.isArray(apiData?.days) ? apiData.days : [];
            arr.forEach(d=>{
                const date = String(d.date);
                const segments = Array.isArray(d.segments) ? d.segments : [];
                const minutes = (typeof d.minutes==='number')
                        ? d.minutes
                        : segments.reduce((acc,s)=>acc+diffMinutes(s.start,s.end),0);
                map[date] = { segments, minutes };
            });
            return map;
        }

        function showAlert(msg, type='info'){
            alertArea.innerHTML = `<div class="alert alert-${type} py-2 px-3" role="alert">${escapeHtml(msg)}</div>`;
        }
        function clearAlert(){ alertArea.innerHTML=''; }

    })();
</script>

{{>layouts/footer}}
