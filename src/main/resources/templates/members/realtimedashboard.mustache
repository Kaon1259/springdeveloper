{{>layouts/header}}

<main class="container my-4">
    <div class="card">
        <div class="card-header fw-bold d-flex justify-content-between align-items-center">
            <span>금(2025-11-08) 근무 현황</span>
            <small class="text-muted" id="nowClock">--:--</small>
        </div>

        <div class="card-body">
            <!-- ====== STICKY: 금일 근무자 나열 ====== -->
            <div id="stickyChips" class="sticky-chips">
                <div class="d-flex align-items-center justify-content-between mb-2 flex-wrap gap-2">
                    <div class="d-flex align-items-center gap-2 flex-wrap">
                        <div class="small text-muted">금일 근무자</div>

                        <!-- ✅ 실근무시간 등록 버튼 -->
                        <button id="btnRegisterActual" class="btn btn-sm btn-success">
                            실근무시간 등록
                        </button>

                        <!-- ✅ 단위 선택 버튼 그룹 -->
                        <div class="btn-group btn-group-sm ms-1" role="group" aria-label="슬롯 단위 선택">
                            <button type="button"
                                    class="btn btn-outline-secondary"
                                    data-step-btn
                                    data-step="10">
                                10분 단위
                            </button>
                            <button type="button"
                                    class="btn btn-outline-secondary active"
                                    data-step-btn
                                    data-step="30">
                                30분 단위
                            </button>
                            <button type="button"
                                    class="btn btn-outline-secondary"
                                    data-step-btn
                                    data-step="60">
                                60분 단위
                            </button>
                        </div>
                    </div>

                    <span id="memberCountBadge" class="badge bg-light text-dark">0명</span>
                </div>

                <!-- ✅ 칩을 절대배치로 놓을 트랙 -->
                <div id="chipsTrack" class="chips-track">
                    <!-- JS가 칩들을 절대배치로 생성/동기화 -->
                </div>
            </div>

            <!-- 타임테이블 (단위 선택에 따라 10/30/60분 단위로 동적 변경) -->
            <div class="table-responsive" id="ttScroll">
                <table class="table table-bordered align-middle text-center timetable-10m" id="tt10m">
                    <thead>
                    <tr id="tt10mHead">
                        <th style="width:80px;">시간</th>
                        <!-- JS가 금일 근무자 이름으로 동적 th 생성 -->
                        <!-- 마지막에 '시간대 합' th 생성 -->
                    </tr>
                    </thead>
                    <tbody id="tt10mBody">
                    <!-- JS가 HOUR_START~HOUR_END, 선택 단위 간격으로 행 생성 -->
                    </tbody>
                </table>
            </div>

            <div class="small text-muted mt-2">
                * 노란색: 계획된 스케줄 / 연두색(진하게): 현재 시각까지 경과한 구간(선택된 단위로 업데이트) /
                오른쪽 '시간대 합'은 해당 시간에 근무 예정 인원 수
            </div>
        </div>
    </div>
</main>

<style>
    .timetable-10m th, .timetable-10m td { vertical-align: middle; }
    .timecell { font-variant-numeric: tabular-nums; }

    .sticky-chips{
        position: sticky;
        top: var(--sticky-offset, 8px);
        z-index: 20;
        background: #fff;
        border: 1px solid #f1f3f5;
        border-radius: 10px;
        padding: 10px 12px;
        margin-bottom: 12px;
        transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
        overflow: hidden;
    }
    .sticky-chips.is-stuck{
        box-shadow: 0 6px 18px rgba(0,0,0,.06);
        border-color: #e9ecef;
        background: #ffffffcc;
        backdrop-filter: saturate(120%) blur(2px);
    }
    .chips-track{ position: relative; height: 38px; }

    .member-chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 10px;
        background: #fff;
        border: 1px solid #eee;
        max-width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        position: absolute;
        top: 0;
        transform: translateX(0);
        width: 140px;
    }
    .member-chip .name { font-weight: 600; }
    .member-chip .plan { color:#6c757d; font-size:.85rem; white-space: nowrap; }
    .dot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid rgba(0,0,0,.08); flex: 0 0 auto; }

    .slot-10m {
        height: 14px;
        border: 1px solid #eef2f6;
        border-radius: 3px;
        background: #fff;
    }
    .slot-10m.planned { background: rgba(255, 193, 7, .35); border-color: rgba(255, 193, 7, .55); }
    .slot-10m.done    { background: rgba(25, 135, 84, .48); border-color: rgba(25, 135, 84, .62); }

    #tt10m thead th { position: sticky; top: 0; z-index: 2; background: #f8fafc; }
    #tt10m tbody th { position: sticky; left: 0; z-index: 1; background: #fafafa; }

    .now-row th.timecell { background:#fff3cd; }
    .now-row td .slot-10m { box-shadow: inset 0 0 0 1px rgba(255,193,7,.35); }

    .sum-head { width: 100px; }
    .sum-cell { background:#fafafa; font-weight:600; }
    .sum-cell.now-hour { background:#e8f5e9; border-left:2px solid #198754; }

    /* ✅ 현재 시각 + 근무 중 슬롯 주황색 점멸 */
    .slot-10m.blinking {
        animation: slotBlink 1s step-start infinite;
        background: rgba(255, 193, 7, 0.95) !important;
        border-color: rgba(255, 193, 7, 1) !important;
    }
    @keyframes slotBlink {
        0%   { filter: brightness(1.0); box-shadow: 0 0 0 0 rgba(255,193,7,0.0); }
        50%  { filter: brightness(1.35); box-shadow: 0 0 0 2px rgba(255,193,7,0.6); }
        100% { filter: brightness(1.0); box-shadow: 0 0 0 0 rgba(255,193,7,0.0); }
    }
</style>

<script id="membersData" type="application/json">
{{{membersJson}}}
</script>

<script>
    (function () {

        // 로컬 오늘(타임존 기준) 문자열 반환
        function todayStr() {
            const d = new Date();
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2,'0');
            const day = String(d.getDate()).padStart(2,'0');
            return `${y}-${m}-${day}`;
        }

        /** ===== 설정 ===== */
        const API_ENDPOINT = '/api/schedule/actual-bulk-register';
        const TARGET_DATE_STR = todayStr();
        const HOUR_START = 6, HOUR_END = 22;

        // ✅ 기본 단위: 30분
        let STEP_MIN = 30;
        let SLOTS_PER_HOUR = 60 / STEP_MIN;
        let TOTAL_ROWS = (HOUR_END - HOUR_START) * SLOTS_PER_HOUR;

        /** ===== DOM ===== */
        const nowClock = document.getElementById('nowClock');
        const chipsBox = document.getElementById('stickyChips');
        const chipsTrack = document.getElementById('chipsTrack');
        const memberCountBadge = document.getElementById('memberCountBadge');
        const headRow = document.getElementById('tt10mHead');
        const bodyEl = document.getElementById('tt10mBody');
        const scrollBox = document.getElementById('ttScroll');
        const btnRegisterActual = document.getElementById('btnRegisterActual');
        const stepButtons = document.querySelectorAll('[data-step-btn]'); // ✅ 단위 선택 버튼들

        /** ===== 데이터 ===== */
        let allMembers = [];
        try { allMembers = JSON.parse(document.getElementById('membersData').textContent || '[]'); }
        catch (e) { allMembers = []; }

        const targetDate = new Date(`${TARGET_DATE_STR}T00:00:00`);
        const DAY_KEY = dayKeyOf(targetDate);

        const todayMembers = (allMembers || [])
                .filter(m => getSchedules(m).some(s => s.day === DAY_KEY))
                .sort((a,b) => (a.name||'').localeCompare(b.name||'', 'ko'));

        const colorMap = {};
        todayMembers.forEach(m => colorMap[m.id] = colorForMember(m));

        const hourlyTotals = computeHourlyTotals(todayMembers);

        let didAutoScrollOnce = false;
        let lastMinute = -1;

        computeStickyOffset();
        window.addEventListener('resize', computeStickyOffset);
        window.addEventListener('scroll', toggleStickyShadow, { passive: true });

        // 초기 렌더
        renderNow();
        renderChips(todayMembers);
        renderTableHeader(todayMembers);
        renderTableBody();
        paintPlanned(todayMembers);
        updateDoneColors(todayMembers);
        highlightHourSum();
        scrollToNowRow({ smooth: true });
        syncChipsToColumns();

        scrollBox.addEventListener('scroll', syncChipsToColumns, { passive: true });
        window.addEventListener('resize', syncChipsToColumns);
        window.addEventListener('load', syncChipsToColumns);

        btnRegisterActual.disabled = todayMembers.length === 0;

        // ✅ 단위 선택 버튼 이벤트
        stepButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const newStep = parseInt(btn.dataset.step, 10);
                if (!newStep || newStep === STEP_MIN) {
                    // 그래도 active 표시만 정리
                    stepButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    return;
                }

                STEP_MIN = newStep;
                SLOTS_PER_HOUR = 60 / STEP_MIN;
                TOTAL_ROWS = (HOUR_END - HOUR_START) * SLOTS_PER_HOUR;

                // active 토글
                stepButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // 테이블 재렌더
                renderTableBody();
                paintPlanned(todayMembers);
                updateDoneColors(todayMembers);
                highlightHourSum();
                syncChipsToColumns();
                scrollToNowRow({ smooth: true });   // ✅ 단위 변경 후에도 현재 시간 위치로 이동
            });
        });

        /** 안전한 HM 변환 (필요 시 기존 함수 사용) */
        function safeIndexToHM(idx) {
            if (typeof indexToHM === 'function') return indexToHM(idx);
            const totalMin = (HOUR_START * 60) + idx * STEP_MIN;
            const hh = String(Math.floor(totalMin / 60)).padStart(2,'0');
            const mm = String(totalMin % 60).padStart(2,'0');
            return `${hh}:${mm}`;
        }

        // ✅ “실근무시간 등록” 클릭 → 연두색(done) 구간을 멤버별로 압축하여 API 호출
        btnRegisterActual.addEventListener('click', async () => {
            if (!todayMembers.length) return alert('금일 근무자가 없습니다.');

            const confirmMsg = '현재까지의 실제 근무(연두색) 구간을 서버에 등록하시겠습니까?';
            if (!confirm(confirmMsg)) return;

            const items = todayMembers.map(m => {
                const doneIdx = collectDoneIndexesForMember(m.id);
                const ranges = compressIndexesToRanges(doneIdx);
                const segments = ranges.map(([a, b]) => ({
                    start: safeIndexToHM(a),
                    end:   safeIndexToHM(b + 1)
                }));
                return { memberId: m.id, segments };
            }).filter(x => x.segments.length > 0);

            if (!items.length) {
                return alert('등록할 실제 근무 구간(연두색)이 없습니다.');
            }

            const payload = {
                date: todayStr(),
                segments: items
            };

            try {
                const res = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await res.json().catch(() => ({}));
                if (res.ok && (data.success === undefined || data.success === true)) {
                    alert('✅ 실근무시간 등록 완료');
                } else {
                    alert('⚠️ 등록 실패: ' + (data.message || res.statusText || '알 수 없는 오류'));
                    console.error('Server response:', data);
                }
            } catch (err) {
                alert('❌ 네트워크 오류로 등록에 실패했습니다.');
                console.error(err);
            }
        });

        // 15초마다 갱신
        setInterval(() => {
            renderNow();
            updateDoneColors(todayMembers);
            highlightHourSum();

            const now = new Date();
            if (now.getMinutes() !== lastMinute) {
                lastMinute = now.getMinutes();
                scrollToNowRow({ smooth: true });
            } else {
                highlightNowRow();
            }
            syncChipsToColumns();
        }, 15000);

        /** ===== 렌더/동기화 기본들 ===== */
        function renderNow() {
            const d = new Date();
            nowClock.textContent = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
        }
        function renderChips(members) {
            chipsTrack.innerHTML = '';
            memberCountBadge.textContent = `${members.length}명`;
            if (!members.length) {
                chipsTrack.innerHTML = `<span class="text-muted" style="position:absolute;left:0;top:8px;">금일 근무자가 없습니다.</span>`;
                return;
            }
            members.forEach(m => {
                const el = document.createElement('span');
                el.className = 'member-chip';
                el.dataset.memberId = String(m.id);
                el.innerHTML = `
                    <span class="dot" style="background:${colorMap[m.id]}"></span>
                    <span class="name">${escapeHtml(m.name || '-')}</span>
                    <small class="plan">${todayPlanLabel(m) || ''}</small>
                `;
                chipsTrack.appendChild(el);
            });
        }
        function renderTableHeader(members) {
            const memberHeads = members
                    .map(m => `<th data-member-id="${String(m.id)}">${escapeHtml(m.name || '-')}</th>`)
                    .join('');
            const sumHead = `<th class="sum-head">시간대 합</th>`;
            headRow.innerHTML = `<th style="width:80px;">시간</th>${memberHeads}${sumHead}`;
        }
        function renderTableBody() {
            const rows = [];
            for (let i = 0; i < TOTAL_ROWS; i++) {
                const tMin = HOUR_START * 60 + i * STEP_MIN;
                const h = Math.floor(tMin / 60), m = tMin % 60;
                // ✅ 매 시 정각에만 label 표시
                const label = (m === 0)
                        ? `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`
                        : '';

                let row = `
        <tr data-row-index="${i}">
          <th class="timecell">${label}</th>
          ${todayMembers.map(mb => `<td data-member-id="${String(mb.id)}"><div class="slot-10m"></div></td>`).join('')}
      `;
                if (m === 0) {
                    const total = hourlyTotals[h] ?? 0;
                    row += `<td class="sum-cell" data-hour="${h}" rowspan="${SLOTS_PER_HOUR}">${total}명</td>`;
                }
                row += `</tr>`;
                rows.push(row);
            }
            bodyEl.innerHTML = rows.join('');
        }
        function paintPlanned(members) {
            // 현재 테이블에 있는 모든 슬롯 기준으로,
            // 각 멤버의 일정이 "슬롯 시간대와 1분이라도 겹치면" planned 처리
            members.forEach(m => {
                const segs = getSchedules(m).filter(s => s.day === DAY_KEY);
                if (!segs.length) return;

                const slots = bodyEl.querySelectorAll(`td[data-member-id="${String(m.id)}"] .slot-10m`);
                if (!slots.length) return;

                segs.forEach(s => {
                    const st = parseHm(s.start);
                    const ed = parseHm(s.end);
                    const stMin = st.h * 60 + st.m;
                    const edMin = ed.h * 60 + ed.m;

                    for (let i = 0; i < slots.length; i++) {
                        const slotStartMin = HOUR_START * 60 + i * STEP_MIN;
                        const slotEndMin   = slotStartMin + STEP_MIN;

                        const overlap = Math.max(
                                0,
                                Math.min(edMin, slotEndMin) - Math.max(stMin, slotStartMin)
                        );
                        if (overlap > 0) {
                            slots[i].classList.add('planned');
                        }
                    }
                });
            });
        }
        function updateDoneColors(members) {
            const currentIndex = indexFromNow();
            members.forEach(m => {
                const slots = bodyEl.querySelectorAll(`td[data-member-id="${String(m.id)}"] .slot-10m`);
                slots.forEach((slot, i) => {
                    if (slot.classList.contains('planned')) {
                        if (i <= currentIndex - 1) slot.classList.add('done');
                        else slot.classList.remove('done');
                    }
                });
            });
            highlightNowRow();
            updateBlinkingSlots(currentIndex);   // ✅ 현재 시각 행 주황색 점멸 처리
        }
        function highlightNowRow() {
            bodyEl.querySelectorAll('.now-row').forEach(tr => tr.classList.remove('now-row'));
            const idx = indexFromNow();
            const row = bodyEl.querySelector(`tr[data-row-index="${idx}"]`);
            if (row) row.classList.add('now-row');
        }
        function highlightHourSum() {
            bodyEl.querySelectorAll('.sum-cell').forEach(td => td.classList.remove('now-hour'));
            const now = new Date();
            const h = now.getHours();
            const sumTd = bodyEl.querySelector(`.sum-cell[data-hour="${h}"]`);
            if (sumTd) sumTd.classList.add('now-hour');
        }

        // ✅ 현재 시각이 있는 행이 화면 상단 근처로 오도록 스크롤
        function scrollToNowRow({ smooth = false } = {}) {
            const idx = indexFromNow();
            const row = bodyEl.querySelector(`tr[data-row-index="${idx}"]`);
            if (!row) return;

            // ✅ 페이지(문서 스크롤)를 현재 시각 행 기준으로 이동
            if (!didAutoScrollOnce || smooth) {
                row.scrollIntoView({
                    block: 'center',         // 화면 중앙 근처로 위치
                    behavior: smooth ? 'smooth' : 'auto'
                });
                didAutoScrollOnce = true;
            }
        }

        function updateBlinkingSlots(currentIndex) {
            // 이전에 깜빡이던 모든 슬롯 초기화
            bodyEl.querySelectorAll('.slot-10m.blinking')
                    .forEach(el => el.classList.remove('blinking'));

            // 현재 인덱스 행 찾기
            const row = bodyEl.querySelector(`tr[data-row-index="${currentIndex}"]`);
            if (!row) return;

            // 해당 행에서 "근무 중(=planned)"인 슬롯에만 blinking 적용
            row.querySelectorAll('.slot-10m').forEach(el => {
                if (el.classList.contains('planned')) {
                    el.classList.add('blinking');
                }
            });
        }

        /** ===== 칩-컬럼 동기화 ===== */
        function syncChipsToColumns(){
            const headThs = headRow.querySelectorAll('th[data-member-id]');
            if (!headThs.length) return;
            const scrollRect = scrollBox.getBoundingClientRect();
            const scrollLeft = scrollBox.scrollLeft;
            headThs.forEach(th => {
                const id = th.getAttribute('data-member-id');
                const chip = chipsTrack.querySelector(`.member-chip[data-member-id="${CSS.escape(id)}"]`);
                if (!chip) return;
                const rect = th.getBoundingClientRect();
                const leftInScroll = rect.left - scrollRect.left + scrollLeft;
                chip.style.width = `${Math.max(80, th.offsetWidth)}px`;
                chip.style.transform = `translateX(${leftInScroll}px)`;
            });
        }

        /** ===== “실근무시간 등록”에 필요한 유틸 ===== */
        function collectDoneIndexesForMember(memberId){
            const slots = bodyEl.querySelectorAll(`td[data-member-id="${String(memberId)}"] .slot-10m`);
            const idx = [];
            slots.forEach((el, i) => { if (el.classList.contains('done')) idx.push(i); });
            return idx;
        }
        function compressIndexesToRanges(indexes){
            if (!indexes.length) return [];
            const ranges = [];
            let a = indexes[0], p = indexes[0];
            for (let i = 1; i < indexes.length; i++){
                if (indexes[i] === p + 1) { p = indexes[i]; continue; }
                ranges.push([a, p]);
                a = p = indexes[i];
            }
            ranges.push([a, p]);
            return ranges;
        }
        function indexToHM(i){
            const minutesFromStart = i * STEP_MIN;
            const total = HOUR_START * 60 + minutesFromStart;
            const h = Math.floor(total / 60);
            const m = total % 60;
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
        }

        /** ===== Sticky/시간 유틸 ===== */
        function computeStickyOffset(){
            const fixedHeader = document.querySelector('.navbar.fixed-top, .fixed-top, header.sticky-top');
            const hdrH = fixedHeader ? fixedHeader.getBoundingClientRect().height : 0;
            const gap = 8;
            document.documentElement.style.setProperty('--sticky-offset', (hdrH + gap) + 'px');
        }
        function toggleStickyShadow(){
            const top = chipsBox.getBoundingClientRect().top;
            const threshold = (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sticky-offset')) || 0) + 1;
            if (top <= threshold) chipsBox.classList.add('is-stuck');
            else chipsBox.classList.remove('is-stuck');
        }
        function computeHourlyTotals(members) {
            const totals = {};
            for (let h = HOUR_START; h < HOUR_END; h++) {
                let count = 0;
                members.forEach(m => {
                    const segs = getSchedules(m).filter(s => s.day === DAY_KEY);
                    if (segs.some(s => intervalHitHour(parseHm(s.start), parseHm(s.end), h))) count++;
                });
                totals[h] = count;
            }
            return totals;
        }
        function hmToIndex(hm) {
            const [H, M] = String(hm || '0:0').split(':').map(Number);
            const total = H * 60 + M;
            return Math.floor((total - (HOUR_START * 60)) / STEP_MIN);
        }
        function indexFromNow() {
            const now = new Date();
            const base = new Date(now.getFullYear(), now.getMonth(), now.getDate(), HOUR_START, 0, 0);
            const end  = new Date(now.getFullYear(), now.getMonth(), now.getDate(), HOUR_END, 0, 0);
            if (now <= base) return 0;
            if (now >= end) return TOTAL_ROWS - 1;
            const diffMin = Math.floor((now - base) / 60000);
            return Math.min(TOTAL_ROWS - 1, Math.max(0, Math.floor(diffMin / STEP_MIN)));
        }
        function parseHm(hm) {
            const [h,m] = (hm||'0:0').split(':').map(n => parseInt(n,10));
            return {h: h||0, m: m||0};
        }
        function intervalHitHour(st, ed, h) {
            const stMin = st.h*60 + st.m;
            const edMin = ed.h*60 + ed.m;
            const a = h*60, b = (h+1)*60;
            return Math.max(0, Math.min(edMin, b) - Math.max(stMin, a)) > 0;
        }
        function todayPlanLabel(m) {
            const seg = getSchedules(m).find(s => s.day === DAY_KEY);
            return seg ? `${seg.start}–${seg.end}` : '';
        }
        function getSchedules(m) {
            if (Array.isArray(m?.schedule)) return m.schedule;
            if (Array.isArray(m?.schedules)) return m.schedules;
            return [];
        }
        function dayKeyOf(d) {
            return ['SUN','MON','TUE','WED','THU','FRI','SAT'][d.getDay()];
        }
        function escapeHtml(s) {
            if (s == null) return '';
            return String(s)
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
        }
        function colorForMember(m) {
            const key = (m.id != null ? String(m.id) : (m.name || 'x'));
            const h = seededHash(key) % 360;
            const s = 65, l = 55;
            return hslToHex(h, s, l);
        }
        function seededHash(str) { let h = 2166136261>>>0; for (let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0; } return h>>>0; }
        function hslToHex(h, s, l){
            s/=100; l/=100;
            const k=n=>(n + h/30)%12;
            const a=s*Math.min(l,1-l);
            const f=n=>l - a*Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1)));
            const toHex=x=>Math.round(255*x).toString(16).padStart(2,'0');
            return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
        }
    })();
</script>

{{>layouts/footer}}
