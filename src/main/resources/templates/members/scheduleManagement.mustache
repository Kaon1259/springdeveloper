{{>layouts/header}}

<main class="container my-4">

    <!-- ============ 상단: 아르바이트 상태별 보기 (칩 리스트) ============ -->
    <div class="card mb-3">
        <div class="card-header fw-bold d-flex align-items-center justify-content-between">
            <span>아르바이트 상태별 보기</span>
            <span id="statusCountBadge" class="badge bg-secondary">0명</span>
        </div>
        <div class="card-body">
            <div class="row g-3">
                <div class="col-12 col-md-4">
                    <label class="form-label small text-muted" for="statusSelect">상태</label>
                    <select id="statusSelect" class="form-select">
                        <option value="WORKING" selected>근무중</option>
                        <option value="WAITING">시작전</option>
                        <option value="RESTING">휴식중</option>
                        <option value="PAUSED">일시중지</option>
                        <option value="RESIGNED">퇴사</option>
                    </select>
                    <div class="form-text">
                        상태를 바꾸면 아래 리스트와 월간 일정이 함께 바뀝니다.
                    </div>
                </div>

                <div class="col-12 col-md-8">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="small text-muted">필터된 아르바이트생</span>
                        <span id="statusCountBadgeTop" class="badge bg-secondary d-none"></span>
                    </div>

                    <!-- 칩( pill ) 리스트 -->
                    <div id="memberPills" class="vlist"></div>

                    <div class="small text-muted mt-2">
                        * 각 사람 옆의 색상은 근로자의 고유 색입니다. (달력 일정에도 동일 색상 사용 예정)
                    </div>

                    <div class="mt-2 d-flex align-items-center gap-3">
                        <span class="legend legend-plan"></span><span class="small">계획(주간 템플릿)</span>
                        <span class="legend legend-actual"></span><span class="small">저장된 일정</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ============ NEW: 상태별 월간 근무 캘린더 ============ -->
    <div class="card mb-3">
        <div class="card-header fw-bold">
            상태별 월간 근무 캘린더
        </div>
        <div class="card-body">
            <div class="small text-muted mb-2">
                현재 선택된 상태의 아르바이트생들이 이 달에 근무하는 날짜를 한눈에 볼 수 있습니다.
            </div>
            <div class="table-responsive">
                <table class="table table-bordered table-sm align-middle text-center status-month-table" id="statusMonthTable">
                    <thead>
                    <tr id="statusMonthHeadRow"></tr>
                    </thead>
                    <tbody id="statusMonthBody">
                    <!-- JS 렌더 -->
                    </tbody>
                </table>
            </div>
            <div class="small text-muted mt-1">
                행을 클릭하면 해당 근로자가 아래 월간 일정 영역에 선택됩니다.
                (선택된 근로자는 이 표에서 <strong>하이라이트</strong> 됩니다.)
            </div>
        </div>
    </div>

    <!-- ============ 하단: 월간 타임테이블 (개별 근로자) ============ -->
    <div class="card">
        <!-- ✅ 네비게이션바 높이를 고려하는 sticky 헤더 -->
        <div id="monthCardHeader"
             class="card-header fw-bold d-flex align-items-center justify-content-between">
          <span>
            선택 월 실제 일정
            <small id="selectedMemberNameRight" class="text-muted ms-2">[근로자: 없음]</small>
            <span id="selectedMemberStatusRight" class="badge bg-secondary ms-2 d-none">-</span>
          </span>
            <div class="d-flex align-items-center gap-2">
                <button id="btnMonthPrev" class="btn btn-sm btn-outline-secondary">◀ 이전 달</button>
                <span id="monthRangeLabel" class="small text-muted">0000.00.01 ~ 00.00</span>
                <button id="btnMonthThis" class="btn btn-sm btn-outline-secondary">이번 달</button>
                <button id="btnMonthNext" class="btn btn-sm btn-outline-secondary">다음 달 ▶</button>
            </div>
        </div>
        <div class="card-body">

            <div id="emptyState" class="d-none text-center py-4">
                <div class="mb-2 text-muted">이 달에는 저장된 일정이 없습니다.</div>
                <button id="btnCreateFromEmpty" class="btn btn-primary btn-sm">일정 생성하기</button>
            </div>

            <!-- ✅ 요일 헤더 (sticky 대상) -->
            <div class="calendar-dow-row d-none" id="calendarDowRow"></div>

            <!-- 날짜 칸 그리드 -->
            <div class="calendar-grid d-none" id="calendarGrid"></div>

            <div class="mt-3">
                <div class="d-flex justify-content-between">
                    <div class="small text-muted">월 합계(실근무)</div>
                    <div class="fw-semibold" id="monthActualTotalCell">0시간</div>
                </div>
            </div>
            <div class="small text-muted mt-2">
                * 날짜 칸을 클릭하면 선택되고, 날짜와 요일 사이에 작은 <b>[수정]</b> 버튼이 나타납니다.
            </div>
            <span id="monthLabel" class="d-none">0000-00-01</span>
        </div>
    </div>
</main>

<!-- ===== 편집 모달 (하루 10분 격자) ===== -->
<div class="modal" id="editModal" style="display:none;">
    <div class="modal-dialog">
        <div class="modal-content p-3">
            <div class="d-flex justify-content-between align-items-center mb-2 edit-modal-header">
                <div class="fw-bold">
                    <span id="editTitleDate">0000-00-00</span>
                    <span class="text-muted">/</span>
                    <span id="editTitleMember">알바생 이름</span>
                </div>
                <div class="d-flex gap-2">
                    <button id="btnSaveEdit" class="btn btn-sm btn-primary">저장</button>
                    <button id="btnCancelEdit" class="btn btn-sm btn-outline-secondary">취소</button>
                    <button id="btnCloseModal" class="btn btn-sm btn-outline-dark">닫기</button>
                </div>
            </div>

            <div class="edit-modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="small text-muted">10분 슬롯을 드래그로 선택/해제할 수 있습니다. (06:00 ~ 22:00)</span>
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="btnClearAllSlots">전체 초기화</button>
                </div>

                <!-- 하루 10분 격자 -->
                <div class="day-grid mb-2">
                    <table id="dayGridTable">
                        <thead>
                        <tr>
                            <th style="width:74px;">시간</th>
                            <th>선택</th>
                        </tr>
                        </thead>
                        <tbody id="dayGridBody">
                        <!-- JS 렌더: 06:00~22:00, 10분 단위 (96행) -->
                        </tbody>
                    </table>
                </div>

                <div class="text-end small">
                    총 선택: <span id="selectedMinutes" class="fw-bold">0</span>분
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    :root {
        /* 네비게이션바 + 카드헤더 높이 합산 값 (JS에서 실제 값으로 바뀜) */
        --month-header-height: 80px;
    }

    .legend { display:inline-block; width:14px; height:14px; border-radius:3px; border:1px solid #ddd; vertical-align:middle; }
    .legend-plan { background: rgba(13,110,253,.25); border-color: rgba(13,110,253,.45); }
    .legend-actual { background: rgba(25,135,84,.25); border-color: rgba(25,135,84,.40); }

    /* ===== 아르바이트 리스트: 칩 스타일 ===== */
    .vlist {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }
    .pill {
        display:flex;
        align-items:center;
        gap:8px;
        padding:8px 10px;
        border-radius:999px;
        border:1px solid #e9ecef;
        background:#fff;
        cursor:pointer;
        font-size:.9rem;
        transition: background .15s, box-shadow .15s, border-color .15s;
    }
    .pill:hover {
        background:#fafafa;
        border-color:#dee2e6;
    }
    .pill.active {
        border-color: rgba(13,110,253,.45);
        box-shadow:0 0 0 3px rgba(13,110,253,.15) inset;
        background:#f0f6ff;
    }
    .pill .dot {
        width:12px;
        height:12px;
        border-radius:50%;
        border:1px solid rgba(0,0,0,.08);
        flex:0 0 12px;
    }
    .pill .name {
        font-weight:600;
    }
    .pill .meta {
        color:#6c757d;
        font-size:.8rem;
    }

    /* 급여/일정 테이블 래퍼 – sticky 기준 컨테이너 */
    .pay-right-wrapper {
        position: relative;
    }

    /* ✅ 카드 헤더: 네비게이션바 아래에서 sticky */
    #monthCardHeader {
        position: sticky;
        top: 0; /* JS에서 nav 높이만큼으로 재설정됨 */
        z-index: 30;
        background: #fff;
    }

    /* ✅ 요일 줄: "네비 + 카드헤더" 아래에 sticky */
    .calendar-dow-row {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        position: sticky;
        top: var(--month-header-height);
        z-index: 25;
        background: #fff;
        padding-bottom: 4px;
    }
    .calendar-dow-row .dow {
        text-align:center;
        font-weight:600;
        color:#6c757d;
        padding:6px 0;
        border-bottom:1px dashed #e9ecef;
    }

    /* 날짜 그리드 (개별 근로자 월 캘린더) */
    .calendar-grid {
        display:grid;
        grid-template-columns:repeat(7,1fr);
        gap:8px;
        margin-top: 4px;
    }
    .calendar-grid .cell {
        border:1px solid #e9ecef;
        border-radius:10px;
        padding:8px;
        min-height:120px;
        background:#fff;
        display:flex;
        flex-direction:column;
        gap:6px;
        cursor:pointer;
    }
    .cell .date-head { display:flex; align-items:center; justify-content:space-between; font-weight:600; font-size:.95rem; gap:8px; }
    .date-head .mid-actions { margin:0 6px; display:inline-flex; align-items:center; gap:8px; }
    .cell .date-head .dow-mini { color:#6c757d; font-weight:500; font-size:.85rem; }
    .cell .segments { display:flex; flex-wrap:wrap; gap:6px; }
    .cell .day-total { margin-top:auto; text-align:right; font-size:.875rem; color:#212529; }
    .cell.muted { background:#fcfcfc; color:#96a0aa; cursor:default; }
    .cell.today { outline:2px solid #51cf66; outline-offset:2px; }
    .cell.selected { box-shadow:0 0 0 3px rgba(13,110,253,.25) inset; }
    .btn-edit-inline { padding:1px 6px; font-size:.75rem; line-height:1.1; border-radius:10px; }

    /* ===== NEW: 상태별 월간 근무 테이블 ===== */
    .status-month-table th,
    .status-month-table td {
        font-size:.75rem;
        padding:.25rem .35rem;
        white-space:nowrap;
    }
    .status-month-table thead th {
        position: sticky;
        top: 0;
        z-index: 5;
        background: #f8f9fa;
    }
    .status-month-table .member-name-cell {
        text-align:left;
        white-space:nowrap;
    }
    .status-month-table tr.table-active {
        background: rgba(13,110,253,.06);
    }

    /* ===== 상태별 월간 근무 테이블 (사각형 크기 축소 버전) ===== */
    .status-month-table .legend {
        display: inline-block;
        width: 9px;
        height: 9px;
        border-radius: 2px;
        border: 1px solid #ccc;
        margin: 0 auto;
        vertical-align: middle;
    }
    .status-month-table td {
        padding: 0.15rem 0.2rem;
    }
    .status-month-table th {
        padding: 0.25rem 0.35rem;
    }
    .status-month-table tr.table-active {
        background: rgba(13,110,253,.08);
    }

    /* ===== 모달 ===== */
    .modal {
        background: rgba(0,0,0,.35);
        position: fixed;
        inset: 0;
        display: none;
        z-index: 1055;
    }
    .modal-dialog {
        margin: 50px auto;
        max-width: 820px;
    }
    .modal-content {
        background:#fff;
        border-radius:12px;
        box-shadow:0 10px 40px rgba(0,0,0,.2);
    }
    .edit-modal-header {
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
    }
    .edit-modal-body {
        padding-top: 8px;
    }

    /* 하루 10분 그리드 */
    .day-grid {
        width: 100%;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        overflow: hidden;
        user-select: none;
        background:#fff;
        max-height: 70vh;
        overflow-y: auto;
    }
    .day-grid table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        table-layout: fixed;
    }
    .day-grid thead th {
        background: #f8fafc;
        color:#64748b;
        font-weight: 600;
        font-size: 0.95rem;
        border-bottom: 1px solid #e5e7eb;
        text-align: center;
        padding: .6rem .4rem;
        position: sticky;
        top: 0;
        z-index: 2;
    }
    .day-grid tbody th.timecell {
        background: #fafafa;
        color:#6b7280;
        font-weight: 600;
        width: 74px;
        border-right: 1px solid #e5e7eb;
        text-align: center;
        padding: .25rem .25rem;
        font-size: .85rem;
        position: sticky;
        left: 0;
        z-index: 1;
        font-variant-numeric: tabular-nums;
    }
    .row-hour-start td,
    .row-hour-start th {
        border-top: 2px solid #e5e7eb !important;
    }
    .slot-10m {
        border-bottom: 1px dashed #eef2f6;
        height: 18px;
        cursor: pointer;
        background: #ffffff;
    }
    .slot-10m:hover { background: #f8fbff; }
    .slot-10m.selected {
        background: rgba(25,135,84,.18);
        box-shadow: inset 0 0 0 1px rgba(25,135,84,.25);
    }
</style>

<script id="membersData" type="application/json">
{{{membersJson}}}
</script>

<script>
    (function(){
        // ===== DOM =====
        const statusSelect = document.getElementById('statusSelect');
        const memberPills = document.getElementById('memberPills');
        const statusCountBadge = document.getElementById('statusCountBadge');
        const statusCountBadgeTop = document.getElementById('statusCountBadgeTop');

        const selectedMemberNameRight = document.getElementById('selectedMemberNameRight');
        const selectedMemberStatusRight = document.getElementById('selectedMemberStatusRight');

        const calendarDowRow = document.getElementById('calendarDowRow');
        const calendarGrid   = document.getElementById('calendarGrid');
        const emptyState     = document.getElementById('emptyState');
        const btnCreateFromEmpty = document.getElementById('btnCreateFromEmpty');

        const monthLabel = document.getElementById('monthLabel');
        const monthRangeLabel = document.getElementById('monthRangeLabel');
        const btnMonthPrev = document.getElementById('btnMonthPrev');
        const btnMonthThis = document.getElementById('btnMonthThis');
        const btnMonthNext = document.getElementById('btnMonthNext');
        const monthActualTotalCell = document.getElementById('monthActualTotalCell');

        const monthCardHeader = document.getElementById('monthCardHeader');

        // NEW: 상태별 월간 근무 테이블 DOM
        const statusMonthHeadRow = document.getElementById('statusMonthHeadRow');
        const statusMonthBody    = document.getElementById('statusMonthBody');

        // 편집 모달
        const editModal = document.getElementById('editModal');
        const editTitleDate = document.getElementById('editTitleDate');
        const editTitleMember = document.getElementById('editTitleMember');
        const btnSaveEdit = document.getElementById('btnSaveEdit');
        const btnCancelEdit = document.getElementById('btnCancelEdit');
        const btnCloseModal = document.getElementById('btnCloseModal');
        const dayGridBody = document.getElementById('dayGridBody');
        const btnClearAllSlots = document.getElementById('btnClearAllSlots');
        const selectedMinutesEl = document.getElementById('selectedMinutes');

        const API_ENDPOINT = '/api/schedule/work';
        const API_UPDATE_ENDPOINT = '/api/schedule/work/update';

        // ===== 상태 =====
        let allMembers = [];
        try { allMembers = JSON.parse(document.getElementById('membersData').textContent || '[]'); } catch(e){ allMembers = []; }
        if(Array.isArray(allMembers) && allMembers.length>0){
            statusSelect.value = allMembers[0].status || 'WORKING';
        }

        let currentMember = null;
        let currentMonthStart = firstDayOfMonth(new Date());

        // 현재 상태에 해당하는 멤버 목록 (새 테이블에서도 사용)
        let currentStatusMembers = [];

        // 달력 선택 상태
        let selectedCellEl = null;
        let selectedDateIso = null;

        // 모달 편집 상태
        const SLOT_MINUTES = 10;
        const START_HOUR = 6;
        const END_HOUR = 22; // exclusive
        const START_MIN = START_HOUR * 60;
        const END_MIN   = END_HOUR * 60;
        const STEP_MIN  = SLOT_MINUTES;
        const TOTAL_ROWS = (END_MIN - START_MIN) / STEP_MIN; // 96
        let originalSegments = [];
        let slotState = new Set(); // "HH:MM" 문자열 집합

        // 드래그 선택
        let dragging = false;
        let dragAdding = true;

        // 상태별 월간 표 비동기 렌더 버전 관리
        let statusMonthRenderSeq = 0;

        // ✅ 네비게이션바 + 카드헤더 높이 계산하여 sticky 위치 보정
        function updateMonthHeaderOffset() {
            if (!monthCardHeader) return;

            const fixedHeader =
                    document.querySelector('.navbar.fixed-top, .fixed-top, header.sticky-top');

            const navH = fixedHeader
                    ? fixedHeader.getBoundingClientRect().height
                    : 0;

            const headerH = monthCardHeader.getBoundingClientRect().height || 0;

            monthCardHeader.style.top = navH + 'px';

            const dowOffset = navH + headerH;
            document.documentElement.style.setProperty('--month-header-height', dowOffset + 'px');
        }

        updateMonthHeaderOffset();
        window.addEventListener('resize', updateMonthHeaderOffset);

        // 초기
        attachHandlers();
        renderMembersByStatus(); // 첫 렌더

        // ===== 이벤트 =====
        function attachHandlers(){
            statusSelect.addEventListener('change', ()=> renderMembersByStatus());
            btnMonthPrev.addEventListener('click', (e)=>{ e.preventDefault(); shiftMonth(-1); });
            btnMonthNext.addEventListener('click', (e)=>{ e.preventDefault(); shiftMonth(+1); });
            btnMonthThis.addEventListener('click', (e)=>{ e.preventDefault(); goToThisMonth(); });

            if(btnCreateFromEmpty){
                btnCreateFromEmpty.addEventListener('click', ()=>{
                    if(!currentMember){
                        alert('근로자를 먼저 선택하세요.');
                        return;
                    }

                    const baseMonthIso =
                            (monthLabel.textContent || '').trim()
                            || toIso(currentMonthStart);

                    const url =
                            `/schedules/generator` +
                            `?memberId=${encodeURIComponent(currentMember.id)}` +
                            `&baseMonth=${encodeURIComponent(baseMonthIso)}`;

                    window.open(
                            url,
                            'scheduleGenerator',
                            'width=1200,height=800,top=80,left=80,scrollbars=yes,resizable=yes'
                    );
                });
            }

            btnSaveEdit.addEventListener('click', onSaveEdit);
            btnCancelEdit.addEventListener('click', onCancelEdit);
            btnCloseModal.addEventListener('click', closeEditModal);
            editModal.addEventListener('click', (e)=>{ if(e.target===editModal) closeEditModal(); });

            btnClearAllSlots.addEventListener('click', ()=>{
                slotState.clear();
                dayGridBody.querySelectorAll('.slot-10m.selected').forEach(el=>el.classList.remove('selected'));
                updateSelectedMinutes();
            });

            window.addEventListener('mouseup', ()=>{
                if(dragging){
                    dragging = false;
                }
            });
        }

        // ===== 멤버 렌더 (칩 리스트 + 선택 유지) =====
        function renderMembersByStatus(){
            const status = statusSelect.value;
            const filtered = (allMembers||[]).filter(m=>m.status===status);
            currentStatusMembers = filtered;

            statusCountBadge.textContent = `${filtered.length}명`;
            if(statusCountBadgeTop){
                statusCountBadgeTop.textContent = `${filtered.length}명`;
                statusCountBadgeTop.classList.remove('d-none');
            }

            memberPills.innerHTML = '';

            if(!filtered.length){
                memberPills.innerHTML = `<span class="text-muted small">해당 상태의 아르바이트생이 없습니다.</span>`;
                selectMember(null);

                // 상태별 월간 표도 초기화
                if (statusMonthHeadRow && statusMonthBody) {
                    statusMonthHeadRow.innerHTML = '';
                    statusMonthBody.innerHTML = '';
                }
                return;
            }

            let toSelect = null;
            if(currentMember && filtered.some(x => String(x.id) === String(currentMember.id))){
                toSelect = filtered.find(x => String(x.id) === String(currentMember.id));
            } else {
                toSelect = filtered[0];
            }

            filtered
                    .slice()
                    .sort((a,b)=>(a.name||'').localeCompare(b.name||'', 'ko'))
                    .forEach(m=>{
                        const color = colorForMember(m);

                        const row = document.createElement('button');
                        row.type = 'button';
                        row.className = 'pill';
                        row.dataset.memberId = String(m.id);
                        row.innerHTML = `
                        <span class="dot" style="background:${color}"></span>
                        <span class="name">${escapeHtml(m.name ?? '-')}</span>
                        <span class="meta">${escapeHtml(m.phone ?? '')}</span>
                    `;
                        row.addEventListener('click', (evt)=>{
                            evt.preventDefault();
                            evt.stopPropagation();
                            selectMember(m);
                        });
                        memberPills.appendChild(row);
                    });

            // 여기서 selectMember → renderMonthCalendar → renderStatusMonthTable 흐름으로 연결
            selectMember(toSelect, {keepCalendar:true});
        }

        function selectMember(m, opts={keepCalendar:false}){
            currentMember = m;

            Array.from(memberPills.querySelectorAll('.pill')).forEach(el=>el.classList.remove('active'));
            if(m){
                const active = memberPills.querySelector(`.pill[data-member-id="${m.id}"]`);
                if(active) active.classList.add('active');
            }

            updateSelectedBadgeAndName();
            clearSelectedCell();
            renderStatusMonthHighlight();

            if(currentMember){
                renderMonthCalendar(currentMember, currentMonthStart);
            }else{
                clearCalendar();
            }
        }

        function updateSelectedBadgeAndName(){
            if(!currentMember){
                selectedMemberNameRight.textContent = '[근로자: 없음]';
                selectedMemberStatusRight.classList.add('d-none');
                selectedMemberStatusRight.textContent = '-';
                selectedMemberStatusRight.className = 'badge bg-secondary ms-2 d-none';
                return;
            }
            const name = currentMember.name ?? '-';
            selectedMemberNameRight.textContent = `(${name})`;

            const badgeMap={WORKING:'bg-success',WAITING:'bg-secondary',RESTING:'bg-info',PAUSED:'bg-warning',RESIGNED:'bg-danger'};
            selectedMemberStatusRight.classList.remove('d-none');
            selectedMemberStatusRight.textContent = currentMember.status || '-';
            selectedMemberStatusRight.className = `badge ${badgeMap[currentMember.status]||'bg-secondary'} ms-2`;
        }

        // ===== NEW: 상태별 월간 근무 표 렌더 =====
        async function renderStatusMonthTable(){
            if(!statusMonthHeadRow || !statusMonthBody) return;

            // 이 호출에 대한 시퀀스 번호
            const mySeq = ++statusMonthRenderSeq;

            statusMonthHeadRow.innerHTML = '';
            statusMonthBody.innerHTML = '';

            const members = currentStatusMembers || [];
            if(!members.length){
                return;
            }

            const ms = firstDayOfMonth(currentMonthStart);
            const me = lastDayOfMonth(currentMonthStart);
            const daysInMonth = me.getDate();
            const msIso = toIso(ms);
            const meIso = toIso(me);

            const DOW_HEAD = ['일','월','화','수','목','금','토'];

            // 헤더
            let headHtml = `<th style="min-width:120px;">근로자</th>`;
            for(let d=1; d<=daysInMonth; d++){
                const dateObj = new Date(ms.getFullYear(), ms.getMonth(), d);
                const dow = dateObj.getDay();
                const dowLabel = DOW_HEAD[dow];
                headHtml += `<th class="small">${d}<br><span class="text-muted">${dowLabel}</span></th>`;
            }
            headHtml += `<th style="min-width:90px;">합계</th>`;
            statusMonthHeadRow.innerHTML = headHtml;

            // 각 멤버별 dayMap 조회
            const memberDayMaps = {};
            await Promise.all(members.map(async m=>{
                try{
                    const url = `${API_ENDPOINT}/${encodeURIComponent(m.id)}/${msIso}/${meIso}`;
                    const resp = await fetch(url, { headers: { 'Accept':'application/json' } });
                    if(!resp.ok) return;
                    const data = await resp.json();
                    memberDayMaps[m.id] = normalizeActualDays(data);
                }catch(e){
                    console.error(e);
                }
            }));

            // 이 사이에 더 최신 렌더 요청이 들어왔으면 결과 무시
            if (mySeq !== statusMonthRenderSeq) {
                return;
            }

            members.forEach(m=>{
                const color = colorForMember(m);
                const dayMap = memberDayMaps[m.id] || {};
                let rowMinutes = 0;
                let cellsHtml = '';

                for(let d=1; d<=daysInMonth; d++){
                    const dateObj = new Date(ms.getFullYear(), ms.getMonth(), d);
                    const iso = toIso(dateObj);
                    const info = dayMap[iso] || {minutes:0};
                    const mins = info.minutes || 0;
                    rowMinutes += mins;

                    if(mins > 0){
                        cellsHtml += `<td><span class="legend" style="background:${color};border-color:${color};"></span></td>`;
                    }else{
                        cellsHtml += `<td class="text-muted">-</td>`;
                    }
                }

                const tr = document.createElement('tr');
                tr.dataset.memberId = String(m.id);
                tr.innerHTML =
                        `<th scope="row" class="member-name-cell">
                        <span class="legend" style="background:${color};border-color:${color}"></span>
                        <span class="ms-1">${escapeHtml(m.name ?? '-')}</span>
                     </th>
                     ${cellsHtml}
                     <td class="text-end small">${formatMins(rowMinutes)}</td>`;

                // 행 클릭 -> 해당 근로자를 선택
                tr.addEventListener('click', ()=>{
                    selectMember(m);
                });

                statusMonthBody.appendChild(tr);
            });

            renderStatusMonthHighlight();
        }

        function renderStatusMonthHighlight(){
            if(!statusMonthBody) return;
            const rows = statusMonthBody.querySelectorAll('tr');
            rows.forEach(tr=>{
                const mid = tr.dataset.memberId;
                const active = currentMember && String(currentMember.id) === String(mid);
                tr.classList.toggle('table-active', !!active);
            });
        }

        // ===== 개별 근로자 월 캘린더 =====
        async function renderMonthCalendar(member, baseDate){
            const ms = firstDayOfMonth(baseDate);
            const me = lastDayOfMonth(baseDate);
            currentMonthStart = ms;

            const monthStartIso = toIso(ms), monthEndIso = toIso(me);
            monthLabel.textContent = monthStartIso;
            monthRangeLabel.textContent = `${ms.getFullYear()}.${pad2(ms.getMonth()+1)}.01 ~ ${pad2(me.getMonth()+1)}.${pad2(me.getDate())}`;

            let dayMap = {};
            try{
                const url = `${API_ENDPOINT}/${encodeURIComponent(member.id)}/${monthStartIso}/${monthEndIso}`;
                const resp = await fetch(url, { headers: { 'Accept':'application/json' } });
                if(resp.ok){
                    const data = await resp.json();
                    dayMap = normalizeActualDays(data);
                }
            }catch(e){ console.error(e); }

            const DOW_HEAD = ['일','월','화','수','목','금','토'];

            // ✅ 요일 헤더 구성
            calendarDowRow.innerHTML = '';
            DOW_HEAD.forEach(label=>{
                const h = document.createElement('div');
                h.className = 'dow';
                h.textContent = label;
                calendarDowRow.appendChild(h);
            });

            // 날짜 그리드
            calendarGrid.innerHTML = '';

            const firstDow = ms.getDay();
            for(let i=0;i<firstDow;i++){
                const blank = document.createElement('div');
                blank.className = 'cell muted';
                calendarGrid.appendChild(blank);
            }

            let monthMinutes = 0;
            let anySegments = false;
            const todayIso = toIso(new Date());

            for(let d=new Date(ms); d<=me; d.setDate(d.getDate()+1)){
                const iso = toIso(d);
                const dow = d.getDay();
                const day = dayMap[iso] || {segments:[], minutes:0};
                monthMinutes += (day.minutes||0);
                if((day.segments||[]).length>0) anySegments = true;

                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.date = iso;
                if(iso===todayIso) cell.classList.add('today');

                const chipsHtml = (day.segments?.length)
                        ? day.segments.map(s=>chipHtml('#198754', s.start, s.end)).join(' ')
                        : '<span class="text-muted small">—</span>';

                cell.innerHTML = `
                <div class="date-head">
                  <span class="date-text">${d.getDate()}일</span>
                  <span class="mid-actions"></span>
                  <span class="dow-mini">${DOW_HEAD[dow]}</span>
                </div>
                <div class="segments">${chipsHtml}</div>
                <div class="day-total">${formatMins(day.minutes||0)}</div>`;

                cell.addEventListener('click', (evt)=>{
                    if(cell.classList.contains('muted')) return;
                    onSelectCell(cell, iso, day.segments||[]);
                });

                calendarGrid.appendChild(cell);
            }

            monthActualTotalCell.textContent = formatMins(monthMinutes);

            if(!anySegments){
                emptyState.classList.remove('d-none');
                calendarGrid.classList.add('d-none');
                calendarDowRow.classList.add('d-none');
            } else {
                emptyState.classList.add('d-none');
                calendarGrid.classList.remove('d-none');
                calendarDowRow.classList.remove('d-none');
            }

            // 월이 바뀌었을 수 있으니 상태별 캘린더도 다시 그림
            renderStatusMonthTable();
        }

        function onSelectCell(cellEl, dateIso, segments){
            clearSelectedCell();
            selectedCellEl = cellEl;
            selectedDateIso = dateIso;
            selectedCellEl.classList.add('selected');

            const mid = selectedCellEl.querySelector('.mid-actions');
            if(mid){
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'btn btn-outline-primary btn-edit-inline';
                btn.textContent = '수정';
                btn.addEventListener('click', (evt)=>{
                    evt.stopPropagation();
                    openEditModal(dateIso, segments);
                });
                mid.appendChild(btn);
            }
        }

        function clearSelectedCell(){
            if(!selectedCellEl) return;
            selectedCellEl.classList.remove('selected');
            const midPrev = selectedCellEl.querySelector('.mid-actions');
            if(midPrev) midPrev.innerHTML = '';
            selectedCellEl = null;
            selectedDateIso = null;
        }

        function clearCalendar(){
            calendarGrid.innerHTML='';
            calendarDowRow.innerHTML='';
            monthRangeLabel.textContent='0000.00.01 ~ 00.00';
            monthActualTotalCell.textContent='0시간';
            emptyState.classList.remove('d-none');
            calendarGrid.classList.add('d-none');
            calendarDowRow.classList.add('d-none');
            clearSelectedCell();
        }

        function shiftMonth(offset){
            currentMonthStart = firstDayOfMonth(new Date(currentMonthStart.getFullYear(), currentMonthStart.getMonth()+offset, 1));
            clearSelectedCell();
            if(currentMember){ renderMonthCalendar(currentMember, currentMonthStart); }
            else { renderStatusMonthTable(); }
        }
        function goToThisMonth(){
            currentMonthStart = firstDayOfMonth(new Date());
            clearSelectedCell();
            if(currentMember){ renderMonthCalendar(currentMember, currentMonthStart); }
            else { renderStatusMonthTable(); }
        }

        // ===== 편집 모달 =====
        function openEditModal(dateIso, segments){
            if(!currentMember) return;

            editTitleDate.textContent = dateIso;
            editTitleMember.textContent = currentMember.name ?? '-';

            originalSegments = Array.isArray(segments) ? segments.slice() : [];
            slotState = segmentsToSlots(originalSegments);

            buildDayGrid();
            updateSelectedMinutes();

            editModal.style.display = 'block';
        }

        function closeEditModal(){ editModal.style.display = 'none'; }
        function onCancelEdit(){
            slotState = segmentsToSlots(originalSegments);
            buildDayGrid();
            updateSelectedMinutes();
        }

        async function onSaveEdit(){
            if(!currentMember || !selectedDateIso) return;

            const segments = slotsToSegments(slotState, SLOT_MINUTES);

            try{
                const body = { memberId: currentMember.id, date: selectedDateIso, segments };
                const resp = await fetch(API_UPDATE_ENDPOINT, {
                    method: 'POST',
                    headers: {'Content-Type':'application/json', 'Accept':'application/json'},
                    body: JSON.stringify(body)
                });
                if(!resp.ok){
                    const text = await resp.text().catch(()=> '');
                    alert(`저장 실패: ${resp.status} ${text}`);
                    return;
                }
                closeEditModal();
                renderMonthCalendar(currentMember, currentMonthStart);
            }catch(e){
                console.error(e);
                alert('저장 중 오류가 발생했습니다.');
            }
        }

        // 하루 10분 그리드 렌더
        function buildDayGrid(){
            dayGridBody.innerHTML = '';
            for(let idx=0; idx<TOTAL_ROWS; idx++){
                const tMin = START_MIN + idx*STEP_MIN;
                const h = Math.floor(tMin/60);
                const m = tMin%60;
                const hmLabel = `${pad2(h)}:${pad2(m)}`;
                const hm = hmLabel;

                const tr = document.createElement('tr');
                if(m===0) tr.classList.add('row-hour-start');

                const th = document.createElement('th');
                th.className = 'timecell';
                th.textContent = (m%30===0) ? hmLabel : '';
                tr.appendChild(th);

                const td = document.createElement('td');
                const div = document.createElement('div');
                div.className = 'slot-10m';
                div.dataset.hm = hm;
                if(slotState.has(hm)){
                    div.classList.add('selected');
                }
                td.appendChild(div);
                tr.appendChild(td);

                dayGridBody.appendChild(tr);
            }
            attachDragHandlers();
        }

        function attachDragHandlers(){
            dayGridBody.querySelectorAll('.slot-10m').forEach(div=>{
                div.addEventListener('mousedown', (e)=>{
                    e.preventDefault();
                    dragging = true;
                    const hm = div.dataset.hm;
                    const has = slotState.has(hm);
                    dragAdding = !has;
                    toggleSlot(div, dragAdding);
                });
                div.addEventListener('mouseenter', ()=>{
                    if(!dragging) return;
                    toggleSlot(div, dragAdding);
                });
            });
        }

        function toggleSlot(el, on){
            const hm = el.dataset.hm;
            if(on){
                if(!slotState.has(hm)){
                    slotState.add(hm);
                    el.classList.add('selected');
                }
            }else{
                if(slotState.has(hm)){
                    slotState.delete(hm);
                    el.classList.remove('selected');
                }
            }
            updateSelectedMinutes();
        }

        function updateSelectedMinutes(){
            selectedMinutesEl.textContent = (slotState.size * SLOT_MINUTES)|0;
        }

        // ===== 유틸 =====
        function firstDayOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
        function lastDayOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }
        function pad2(n){ return String(n).padStart(2,'0'); }
        function toIso(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }

        // ✅ "HH:MM:SS" → "HH:MM" 으로 잘라서 표시하는 함수
        function displayHm(value){
            if(!value) return '';
            const parts = String(value).split(':');
            const h = parseInt(parts[0], 10) || 0;
            const m = parseInt(parts[1], 10) || 0;
            return `${pad2(h)}:${pad2(m)}`;
        }

        // 날짜칸 칩
        function chipHtml(color, start, end){
            return `<span class="chip">
                        <span class="legend" style="background:${color};border-color:${color}"></span>
                        <span class="small">${displayHm(start)} ~ ${displayHm(end)}</span>
                    </span>`;
        }

        function colorForMember(m){
            const key = (m?.id!=null?String(m.id):(m?.name||'x'));
            const h = seededHash(key)%360, s=65, l=55;
            return hslToHex(h,s,l);
        }
        function seededHash(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h*16777619)>>>0; } return h>>>0; }
        function hslToHex(h,s,l){
            s/=100; l/=100;
            const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs((h/60)%2-1)), m=l-c/2;
            let r=0,g=0,b=0;
            if(0<=h&&h<60){ r=c; g=x; b=0; }
            else if(60<=h&&h<120){ r=x; g=c; b=0; }
            else if(120<=h&&h<180){ r=0; g=c; b=x; }
            else if(180<=h&&h<240){ r=0; g=x; b=c; }
            else if(240<=h&&h<300){ r=x; g=0; b=c; }
            else { r=c; g=0; b=x; }
            const toHex = v => Math.round((v+m)*255).toString(16).padStart(2,'0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        function escapeHtml(s){
            if(s==null) return '';
            return String(s)
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
        }

        function formatMins(mins){
            const v = Math.max(0, mins|0);
            const h=Math.floor(v/60), m=v%60;
            return m===0?`${h}시간`:`${h}시간 ${m}분`;
        }

        function normalizeActualDays(apiData){
            const map = {};
            const arr = Array.isArray(apiData?.days) ? apiData.days : [];
            arr.forEach(d=>{
                const date = String(d.date);
                const segments = Array.isArray(d.segments) ? d.segments : [];
                const minutes = (typeof d.minutes==='number')
                        ? d.minutes
                        : segments.reduce((acc,s)=> acc + (hmToMin(s.end) - hmToMin(s.start)), 0);
                map[date] = { segments, minutes };
            });
            return map;
        }

        function hmToMin(hm){
            if(!hm) return 0;
            const parts = String(hm).split(':').map(n=>parseInt(n,10));
            const h = parts[0] || 0;
            const m = parts[1] || 0;
            return h*60 + m;
        }
        function minToHm(min){ const h=Math.floor(min/60), m=min%60; return `${pad2(h)}:${pad2(m)}`; }

        function segmentsToSlots(segments){
            const set = new Set();
            const startMin = START_HOUR*60;
            const endMin = END_HOUR*60;
            (segments||[]).forEach(seg=>{
                let s = Math.max(hmToMin(seg.start), startMin);
                let e = Math.min(hmToMin(seg.end), endMin);
                for(let t=s; t<e; t+=SLOT_MINUTES){
                    set.add(minToHm(t));
                }
            });
            return set;
        }

        function slotsToSegments(set, step){
            const sorted = Array.from(set).map(hmToMin).sort((a,b)=>a-b);
            const res = [];
            let i=0;
            while(i<sorted.length){
                let s = sorted[i], t = s + step; i++;
                while(i<sorted.length && sorted[i]===t){ t += step; i++; }
                res.push({start:minToHm(s), end:minToHm(t)});
            }
            return res;
        }
    })();
</script>

{{>layouts/footer}}
